// Code generated by github.com/Yamashou/gqlgenc, DO NOT EDIT.

package gqlclient

import (
	"context"
	"net/http"

	"github.com/Yamashou/gqlgenc/client"
)

type Client struct {
	Client *client.Client
}

func NewClient(cli *http.Client, baseURL string, options ...client.HTTPRequestOption) *Client {
	return &Client{Client: client.NewClient(cli, baseURL, options...)}
}

type RootQueryType struct {
	AuditMetrics           []*GeoMetric                      "json:\"auditMetrics\" graphql:\"auditMetrics\""
	Audits                 *AuditConnection                  "json:\"audits\" graphql:\"audits\""
	Categories             []*CategoryInfo                   "json:\"categories\" graphql:\"categories\""
	Category               *CategoryInfo                     "json:\"category\" graphql:\"category\""
	Chart                  *Chart                            "json:\"chart\" graphql:\"chart\""
	ChartInstallations     *ChartInstallationConnection      "json:\"chartInstallations\" graphql:\"chartInstallations\""
	Charts                 *ChartConnection                  "json:\"charts\" graphql:\"charts\""
	Closure                []*ClosureItem                    "json:\"closure\" graphql:\"closure\""
	Configuration          *PluralConfiguration              "json:\"configuration\" graphql:\"configuration\""
	DeferredUpdates        *DeferredUpdateConnection         "json:\"deferredUpdates\" graphql:\"deferredUpdates\""
	DemoProject            *DemoProject                      "json:\"demoProject\" graphql:\"demoProject\""
	DNSDomain              *DNSDomain                        "json:\"dnsDomain\" graphql:\"dnsDomain\""
	DNSDomains             *DNSDomainConnection              "json:\"dnsDomains\" graphql:\"dnsDomains\""
	DNSRecords             *DNSRecordConnection              "json:\"dnsRecords\" graphql:\"dnsRecords\""
	DockerImage            *DockerImage                      "json:\"dockerImage\" graphql:\"dockerImage\""
	DockerImages           *DockerImageConnection            "json:\"dockerImages\" graphql:\"dockerImages\""
	DockerRepositories     *DockerRepositoryConnection       "json:\"dockerRepositories\" graphql:\"dockerRepositories\""
	EabCredential          *EabCredential                    "json:\"eabCredential\" graphql:\"eabCredential\""
	EabCredentials         []*EabCredential                  "json:\"eabCredentials\" graphql:\"eabCredentials\""
	GroupMembers           *GroupMemberConnection            "json:\"groupMembers\" graphql:\"groupMembers\""
	Groups                 *GroupConnection                  "json:\"groups\" graphql:\"groups\""
	HelpQuestion           *string                           "json:\"helpQuestion\" graphql:\"helpQuestion\""
	Incident               *Incident                         "json:\"incident\" graphql:\"incident\""
	Incidents              *IncidentConnection               "json:\"incidents\" graphql:\"incidents\""
	Installation           *Installation                     "json:\"installation\" graphql:\"installation\""
	Installations          *InstallationConnection           "json:\"installations\" graphql:\"installations\""
	IntegrationWebhook     *IntegrationWebhook               "json:\"integrationWebhook\" graphql:\"integrationWebhook\""
	IntegrationWebhooks    *IntegrationWebhookConnection     "json:\"integrationWebhooks\" graphql:\"integrationWebhooks\""
	Integrations           *IntegrationConnection            "json:\"integrations\" graphql:\"integrations\""
	Invite                 *Invite                           "json:\"invite\" graphql:\"invite\""
	Invites                *InviteConnection                 "json:\"invites\" graphql:\"invites\""
	KeyBackup              *KeyBackup                        "json:\"keyBackup\" graphql:\"keyBackup\""
	KeyBackups             *KeyBackupConnection              "json:\"keyBackups\" graphql:\"keyBackups\""
	LoginMethod            *LoginMethodResponse              "json:\"loginMethod\" graphql:\"loginMethod\""
	LoginMetrics           []*GeoMetric                      "json:\"loginMetrics\" graphql:\"loginMetrics\""
	Me                     *User                             "json:\"me\" graphql:\"me\""
	Notifications          *NotificationConnection           "json:\"notifications\" graphql:\"notifications\""
	OauthConsent           *Repository                       "json:\"oauthConsent\" graphql:\"oauthConsent\""
	OauthIntegrations      []*OauthIntegration               "json:\"oauthIntegrations\" graphql:\"oauthIntegrations\""
	OauthLogin             *Repository                       "json:\"oauthLogin\" graphql:\"oauthLogin\""
	OauthUrls              []*OauthInfo                      "json:\"oauthUrls\" graphql:\"oauthUrls\""
	OidcConsent            *OidcStepResponse                 "json:\"oidcConsent\" graphql:\"oidcConsent\""
	OidcLogin              *OidcStepResponse                 "json:\"oidcLogin\" graphql:\"oidcLogin\""
	OidcLogins             *OidcLoginConnection              "json:\"oidcLogins\" graphql:\"oidcLogins\""
	PlatformMetrics        *PlatformMetrics                  "json:\"platformMetrics\" graphql:\"platformMetrics\""
	PublicKeys             *PublicKeyConnection              "json:\"publicKeys\" graphql:\"publicKeys\""
	Publisher              *Publisher                        "json:\"publisher\" graphql:\"publisher\""
	Publishers             *PublisherConnection              "json:\"publishers\" graphql:\"publishers\""
	Recipe                 *Recipe                           "json:\"recipe\" graphql:\"recipe\""
	Recipes                *RecipeConnection                 "json:\"recipes\" graphql:\"recipes\""
	Repositories           *RepositoryConnection             "json:\"repositories\" graphql:\"repositories\""
	Repository             *Repository                       "json:\"repository\" graphql:\"repository\""
	RepositorySubscription *RepositorySubscription           "json:\"repositorySubscription\" graphql:\"repositorySubscription\""
	ResetToken             *ResetToken                       "json:\"resetToken\" graphql:\"resetToken\""
	Role                   *Role                             "json:\"role\" graphql:\"role\""
	Roles                  *RoleConnection                   "json:\"roles\" graphql:\"roles\""
	Rollouts               *RolloutConnection                "json:\"rollouts\" graphql:\"rollouts\""
	Scaffold               []*ScaffoldFile                   "json:\"scaffold\" graphql:\"scaffold\""
	ScmAuthorization       []*AuthorizationURL               "json:\"scmAuthorization\" graphql:\"scmAuthorization\""
	ScmToken               *string                           "json:\"scmToken\" graphql:\"scmToken\""
	SearchRepositories     *RepositoryConnection             "json:\"searchRepositories\" graphql:\"searchRepositories\""
	SearchUsers            *UserConnection                   "json:\"searchUsers\" graphql:\"searchUsers\""
	Shell                  *CloudShell                       "json:\"shell\" graphql:\"shell\""
	ShellConfiguration     *ShellConfiguration               "json:\"shellConfiguration\" graphql:\"shellConfiguration\""
	Stack                  *Stack                            "json:\"stack\" graphql:\"stack\""
	Stacks                 *StackConnection                  "json:\"stacks\" graphql:\"stacks\""
	Subscriptions          *RepositorySubscriptionConnection "json:\"subscriptions\" graphql:\"subscriptions\""
	Tags                   *GroupedTagConnection             "json:\"tags\" graphql:\"tags\""
	Terraform              *TerraformConnection              "json:\"terraform\" graphql:\"terraform\""
	TerraformInstallations *TerraformInstallationConnection  "json:\"terraformInstallations\" graphql:\"terraformInstallations\""
	TerraformModule        *Terraform                        "json:\"terraformModule\" graphql:\"terraformModule\""
	TerraformProvider      *TerraformProvider                "json:\"terraformProvider\" graphql:\"terraformProvider\""
	TerraformProviders     []*Provider                       "json:\"terraformProviders\" graphql:\"terraformProviders\""
	Test                   *Test                             "json:\"test\" graphql:\"test\""
	TestLogs               *string                           "json:\"testLogs\" graphql:\"testLogs\""
	Tests                  *TestConnection                   "json:\"tests\" graphql:\"tests\""
	Token                  *PersistedToken                   "json:\"token\" graphql:\"token\""
	Tokens                 *PersistedTokenConnection         "json:\"tokens\" graphql:\"tokens\""
	UpgradeQueue           *UpgradeQueue                     "json:\"upgradeQueue\" graphql:\"upgradeQueue\""
	UpgradeQueues          []*UpgradeQueue                   "json:\"upgradeQueues\" graphql:\"upgradeQueues\""
	Users                  *UserConnection                   "json:\"users\" graphql:\"users\""
	Versions               *VersionConnection                "json:\"versions\" graphql:\"versions\""
	Webhooks               *WebhookConnection                "json:\"webhooks\" graphql:\"webhooks\""
}
type RootMutationType struct {
	AcceptIncident            *Incident               "json:\"acceptIncident\" graphql:\"acceptIncident\""
	AcceptLogin               *OauthResponse          "json:\"acceptLogin\" graphql:\"acceptLogin\""
	AcquireLock               *ApplyLock              "json:\"acquireLock\" graphql:\"acquireLock\""
	CompleteIncident          *Incident               "json:\"completeIncident\" graphql:\"completeIncident\""
	CreateArtifact            *Artifact               "json:\"createArtifact\" graphql:\"createArtifact\""
	CreateCard                *Account                "json:\"createCard\" graphql:\"createCard\""
	CreateCrd                 *Crd                    "json:\"createCrd\" graphql:\"createCrd\""
	CreateDemoProject         *DemoProject            "json:\"createDemoProject\" graphql:\"createDemoProject\""
	CreateDNSRecord           *DNSRecord              "json:\"createDnsRecord\" graphql:\"createDnsRecord\""
	CreateDomain              *DNSDomain              "json:\"createDomain\" graphql:\"createDomain\""
	CreateGroup               *Group                  "json:\"createGroup\" graphql:\"createGroup\""
	CreateGroupMember         *GroupMember            "json:\"createGroupMember\" graphql:\"createGroupMember\""
	CreateIncident            *Incident               "json:\"createIncident\" graphql:\"createIncident\""
	CreateInstallation        *Installation           "json:\"createInstallation\" graphql:\"createInstallation\""
	CreateIntegration         *Integration            "json:\"createIntegration\" graphql:\"createIntegration\""
	CreateIntegrationWebhook  *IntegrationWebhook     "json:\"createIntegrationWebhook\" graphql:\"createIntegrationWebhook\""
	CreateInvite              *Invite                 "json:\"createInvite\" graphql:\"createInvite\""
	CreateKeyBackup           *KeyBackup              "json:\"createKeyBackup\" graphql:\"createKeyBackup\""
	CreateMessage             *IncidentMessage        "json:\"createMessage\" graphql:\"createMessage\""
	CreateOauthIntegration    *OauthIntegration       "json:\"createOauthIntegration\" graphql:\"createOauthIntegration\""
	CreateOidcProvider        *OidcProvider           "json:\"createOidcProvider\" graphql:\"createOidcProvider\""
	CreatePlan                *Plan                   "json:\"createPlan\" graphql:\"createPlan\""
	CreatePublicKey           *PublicKey              "json:\"createPublicKey\" graphql:\"createPublicKey\""
	CreatePublisher           *Publisher              "json:\"createPublisher\" graphql:\"createPublisher\""
	CreateQueue               *UpgradeQueue           "json:\"createQueue\" graphql:\"createQueue\""
	CreateReaction            *IncidentMessage        "json:\"createReaction\" graphql:\"createReaction\""
	CreateRecipe              *Recipe                 "json:\"createRecipe\" graphql:\"createRecipe\""
	CreateRepository          *Repository             "json:\"createRepository\" graphql:\"createRepository\""
	CreateResetToken          *bool                   "json:\"createResetToken\" graphql:\"createResetToken\""
	CreateRole                *Role                   "json:\"createRole\" graphql:\"createRole\""
	CreateServiceAccount      *User                   "json:\"createServiceAccount\" graphql:\"createServiceAccount\""
	CreateShell               *CloudShell             "json:\"createShell\" graphql:\"createShell\""
	CreateStack               *Stack                  "json:\"createStack\" graphql:\"createStack\""
	CreateSubscription        *RepositorySubscription "json:\"createSubscription\" graphql:\"createSubscription\""
	CreateTerraform           *Terraform              "json:\"createTerraform\" graphql:\"createTerraform\""
	CreateTest                *Test                   "json:\"createTest\" graphql:\"createTest\""
	CreateToken               *PersistedToken         "json:\"createToken\" graphql:\"createToken\""
	CreateUserEvent           *bool                   "json:\"createUserEvent\" graphql:\"createUserEvent\""
	CreateWebhook             *Webhook                "json:\"createWebhook\" graphql:\"createWebhook\""
	CreateZoom                *ZoomMeeting            "json:\"createZoom\" graphql:\"createZoom\""
	DeleteCard                *Account                "json:\"deleteCard\" graphql:\"deleteCard\""
	DeleteChartInstallation   *ChartInstallation      "json:\"deleteChartInstallation\" graphql:\"deleteChartInstallation\""
	DeleteDemoProject         *DemoProject            "json:\"deleteDemoProject\" graphql:\"deleteDemoProject\""
	DeleteDNSRecord           *DNSRecord              "json:\"deleteDnsRecord\" graphql:\"deleteDnsRecord\""
	DeleteDomain              *DNSDomain              "json:\"deleteDomain\" graphql:\"deleteDomain\""
	DeleteEabKey              *EabCredential          "json:\"deleteEabKey\" graphql:\"deleteEabKey\""
	DeleteGroup               *Group                  "json:\"deleteGroup\" graphql:\"deleteGroup\""
	DeleteGroupMember         *GroupMember            "json:\"deleteGroupMember\" graphql:\"deleteGroupMember\""
	DeleteIncident            *Incident               "json:\"deleteIncident\" graphql:\"deleteIncident\""
	DeleteInstallation        *Installation           "json:\"deleteInstallation\" graphql:\"deleteInstallation\""
	DeleteIntegrationWebhook  *IntegrationWebhook     "json:\"deleteIntegrationWebhook\" graphql:\"deleteIntegrationWebhook\""
	DeleteInvite              *Invite                 "json:\"deleteInvite\" graphql:\"deleteInvite\""
	DeleteMessage             *IncidentMessage        "json:\"deleteMessage\" graphql:\"deleteMessage\""
	DeletePublicKey           *PublicKey              "json:\"deletePublicKey\" graphql:\"deletePublicKey\""
	DeleteReaction            *IncidentMessage        "json:\"deleteReaction\" graphql:\"deleteReaction\""
	DeleteRecipe              *Recipe                 "json:\"deleteRecipe\" graphql:\"deleteRecipe\""
	DeleteRepository          *Repository             "json:\"deleteRepository\" graphql:\"deleteRepository\""
	DeleteRole                *Role                   "json:\"deleteRole\" graphql:\"deleteRole\""
	DeleteShell               *CloudShell             "json:\"deleteShell\" graphql:\"deleteShell\""
	DeleteStack               *Stack                  "json:\"deleteStack\" graphql:\"deleteStack\""
	DeleteTerraform           *Terraform              "json:\"deleteTerraform\" graphql:\"deleteTerraform\""
	DeleteToken               *PersistedToken         "json:\"deleteToken\" graphql:\"deleteToken\""
	DeleteUser                *User                   "json:\"deleteUser\" graphql:\"deleteUser\""
	DestroyCluster            *bool                   "json:\"destroyCluster\" graphql:\"destroyCluster\""
	DeviceLogin               *DeviceLogin            "json:\"deviceLogin\" graphql:\"deviceLogin\""
	ExternalToken             *string                 "json:\"externalToken\" graphql:\"externalToken\""
	FollowIncident            *Follower               "json:\"followIncident\" graphql:\"followIncident\""
	ImpersonateServiceAccount *User                   "json:\"impersonateServiceAccount\" graphql:\"impersonateServiceAccount\""
	InstallBundle             []*Installation         "json:\"installBundle\" graphql:\"installBundle\""
	InstallChart              *ChartInstallation      "json:\"installChart\" graphql:\"installChart\""
	InstallRecipe             []*Installation         "json:\"installRecipe\" graphql:\"installRecipe\""
	InstallTerraform          *TerraformInstallation  "json:\"installTerraform\" graphql:\"installTerraform\""
	LinkPublisher             *Publisher              "json:\"linkPublisher\" graphql:\"linkPublisher\""
	Login                     *User                   "json:\"login\" graphql:\"login\""
	LoginToken                *User                   "json:\"loginToken\" graphql:\"loginToken\""
	OauthCallback             *User                   "json:\"oauthCallback\" graphql:\"oauthCallback\""
	OauthConsent              *OauthResponse          "json:\"oauthConsent\" graphql:\"oauthConsent\""
	PasswordlessLogin         *User                   "json:\"passwordlessLogin\" graphql:\"passwordlessLogin\""
	PingWebhook               *WebhookResponse        "json:\"pingWebhook\" graphql:\"pingWebhook\""
	ProvisionDomain           *DNSDomain              "json:\"provisionDomain\" graphql:\"provisionDomain\""
	PublishLogs               *TestStep               "json:\"publishLogs\" graphql:\"publishLogs\""
	QuickStack                *Stack                  "json:\"quickStack\" graphql:\"quickStack\""
	ReadNotifications         *int64                  "json:\"readNotifications\" graphql:\"readNotifications\""
	RealizeInvite             *User                   "json:\"realizeInvite\" graphql:\"realizeInvite\""
	RealizeResetToken         *bool                   "json:\"realizeResetToken\" graphql:\"realizeResetToken\""
	RebootShell               *CloudShell             "json:\"rebootShell\" graphql:\"rebootShell\""
	ReleaseLock               *ApplyLock              "json:\"releaseLock\" graphql:\"releaseLock\""
	ResetInstallations        *int64                  "json:\"resetInstallations\" graphql:\"resetInstallations\""
	RestartShell              *bool                   "json:\"restartShell\" graphql:\"restartShell\""
	Signup                    *User                   "json:\"signup\" graphql:\"signup\""
	SsoCallback               *User                   "json:\"ssoCallback\" graphql:\"ssoCallback\""
	StopShell                 *bool                   "json:\"stopShell\" graphql:\"stopShell\""
	TransferDemoProject       *DemoProject            "json:\"transferDemoProject\" graphql:\"transferDemoProject\""
	UnfollowIncident          *Follower               "json:\"unfollowIncident\" graphql:\"unfollowIncident\""
	UninstallTerraform        *TerraformInstallation  "json:\"uninstallTerraform\" graphql:\"uninstallTerraform\""
	UnlockRepository          *int64                  "json:\"unlockRepository\" graphql:\"unlockRepository\""
	UpdateAccount             *Account                "json:\"updateAccount\" graphql:\"updateAccount\""
	UpdateChart               *Chart                  "json:\"updateChart\" graphql:\"updateChart\""
	UpdateChartInstallation   *ChartInstallation      "json:\"updateChartInstallation\" graphql:\"updateChartInstallation\""
	UpdateDockerRepository    *DockerRepository       "json:\"updateDockerRepository\" graphql:\"updateDockerRepository\""
	UpdateDomain              *DNSDomain              "json:\"updateDomain\" graphql:\"updateDomain\""
	UpdateGroup               *Group                  "json:\"updateGroup\" graphql:\"updateGroup\""
	UpdateIncident            *Incident               "json:\"updateIncident\" graphql:\"updateIncident\""
	UpdateInstallation        *Installation           "json:\"updateInstallation\" graphql:\"updateInstallation\""
	UpdateIntegrationWebhook  *IntegrationWebhook     "json:\"updateIntegrationWebhook\" graphql:\"updateIntegrationWebhook\""
	UpdateLineItem            *RepositorySubscription "json:\"updateLineItem\" graphql:\"updateLineItem\""
	UpdateMessage             *IncidentMessage        "json:\"updateMessage\" graphql:\"updateMessage\""
	UpdateOidcProvider        *OidcProvider           "json:\"updateOidcProvider\" graphql:\"updateOidcProvider\""
	UpdatePlan                *RepositorySubscription "json:\"updatePlan\" graphql:\"updatePlan\""
	UpdatePlanAttributes      *Plan                   "json:\"updatePlanAttributes\" graphql:\"updatePlanAttributes\""
	UpdatePublisher           *Publisher              "json:\"updatePublisher\" graphql:\"updatePublisher\""
	UpdateRepository          *Repository             "json:\"updateRepository\" graphql:\"updateRepository\""
	UpdateRole                *Role                   "json:\"updateRole\" graphql:\"updateRole\""
	UpdateServiceAccount      *User                   "json:\"updateServiceAccount\" graphql:\"updateServiceAccount\""
	UpdateShellConfiguration  *bool                   "json:\"updateShellConfiguration\" graphql:\"updateShellConfiguration\""
	UpdateStep                *TestStep               "json:\"updateStep\" graphql:\"updateStep\""
	UpdateTerraform           *Terraform              "json:\"updateTerraform\" graphql:\"updateTerraform\""
	UpdateTest                *Test                   "json:\"updateTest\" graphql:\"updateTest\""
	UpdateUser                *User                   "json:\"updateUser\" graphql:\"updateUser\""
	UpdateVersion             *Version                "json:\"updateVersion\" graphql:\"updateVersion\""
	UploadTerraform           *Terraform              "json:\"uploadTerraform\" graphql:\"uploadTerraform\""
	UpsertOidcProvider        *OidcProvider           "json:\"upsertOidcProvider\" graphql:\"upsertOidcProvider\""
	UpsertRepository          *Repository             "json:\"upsertRepository\" graphql:\"upsertRepository\""
}
type DNSRecordFragment struct {
	Type    DNSRecordType "json:\"type\" graphql:\"type\""
	Name    string        "json:\"name\" graphql:\"name\""
	Records []*string     "json:\"records\" graphql:\"records\""
}
type ApplyLockFragment struct {
	ID   string  "json:\"id\" graphql:\"id\""
	Lock *string "json:\"lock\" graphql:\"lock\""
}
type ArtifactFragment struct {
	ID       *string           "json:\"id\" graphql:\"id\""
	Name     *string           "json:\"name\" graphql:\"name\""
	Readme   *string           "json:\"readme\" graphql:\"readme\""
	Platform *ArtifactPlatform "json:\"platform\" graphql:\"platform\""
	Arch     *string           "json:\"arch\" graphql:\"arch\""
	Blob     *string           "json:\"blob\" graphql:\"blob\""
	Sha      *string           "json:\"sha\" graphql:\"sha\""
	Filesize *int64            "json:\"filesize\" graphql:\"filesize\""
}
type CloudShellFragment struct {
	ID     string "json:\"id\" graphql:\"id\""
	AesKey string "json:\"aesKey\" graphql:\"aesKey\""
	GitURL string "json:\"gitUrl\" graphql:\"gitUrl\""
}
type ChartFragment struct {
	ID            *string "json:\"id\" graphql:\"id\""
	Name          string  "json:\"name\" graphql:\"name\""
	Description   *string "json:\"description\" graphql:\"description\""
	LatestVersion *string "json:\"latestVersion\" graphql:\"latestVersion\""
}
type DependenciesFragment struct {
	Dependencies []*struct {
		Type *DependencyType "json:\"type\" graphql:\"type\""
		Name *string         "json:\"name\" graphql:\"name\""
		Repo *string         "json:\"repo\" graphql:\"repo\""
	} "json:\"dependencies\" graphql:\"dependencies\""
	Wait        *bool       "json:\"wait\" graphql:\"wait\""
	Application *bool       "json:\"application\" graphql:\"application\""
	Providers   []*Provider "json:\"providers\" graphql:\"providers\""
	Secrets     []*string   "json:\"secrets\" graphql:\"secrets\""
	Wirings     *struct {
		Terraform map[string]interface{} "json:\"terraform\" graphql:\"terraform\""
		Helm      map[string]interface{} "json:\"helm\" graphql:\"helm\""
	} "json:\"wirings\" graphql:\"wirings\""
	ProviderWirings map[string]interface{} "json:\"providerWirings\" graphql:\"providerWirings\""
	Outputs         map[string]interface{} "json:\"outputs\" graphql:\"outputs\""
	ProviderVsn     *string                "json:\"providerVsn\" graphql:\"providerVsn\""
}
type DNSDomainFragment struct {
	ID   string "json:\"id\" graphql:\"id\""
	Name string "json:\"name\" graphql:\"name\""
}
type RecipeSectionFragment struct {
	Index         *int64                         "json:\"index\" graphql:\"index\""
	Repository    *RepositoryFragment            "json:\"repository\" graphql:\"repository\""
	RecipeItems   []*RecipeItemFragment          "json:\"recipeItems\" graphql:\"recipeItems\""
	Configuration []*RecipeConfigurationFragment "json:\"configuration\" graphql:\"configuration\""
}
type RecipeFragment struct {
	ID          string    "json:\"id\" graphql:\"id\""
	Name        string    "json:\"name\" graphql:\"name\""
	Description *string   "json:\"description\" graphql:\"description\""
	Restricted  *bool     "json:\"restricted\" graphql:\"restricted\""
	Provider    *Provider "json:\"provider\" graphql:\"provider\""
	Tests       []*struct {
		Type    TestType "json:\"type\" graphql:\"type\""
		Name    string   "json:\"name\" graphql:\"name\""
		Message *string  "json:\"message\" graphql:\"message\""
		Args    []*struct {
			Name string "json:\"name\" graphql:\"name\""
			Repo string "json:\"repo\" graphql:\"repo\""
			Key  string "json:\"key\" graphql:\"key\""
		} "json:\"args\" graphql:\"args\""
	} "json:\"tests\" graphql:\"tests\""
	Repository *struct {
		ID   string "json:\"id\" graphql:\"id\""
		Name string "json:\"name\" graphql:\"name\""
	} "json:\"repository\" graphql:\"repository\""
	OidcSettings *struct {
		URIFormat  *string        "json:\"uriFormat\" graphql:\"uriFormat\""
		URIFormats []*string      "json:\"uriFormats\" graphql:\"uriFormats\""
		AuthMethod OidcAuthMethod "json:\"authMethod\" graphql:\"authMethod\""
		DomainKey  *string        "json:\"domainKey\" graphql:\"domainKey\""
		Subdomain  *bool          "json:\"subdomain\" graphql:\"subdomain\""
	} "json:\"oidcSettings\" graphql:\"oidcSettings\""
	RecipeSections []*RecipeSectionFragment "json:\"recipeSections\" graphql:\"recipeSections\""
}
type RecipeItemFragment struct {
	ID            *string                        "json:\"id\" graphql:\"id\""
	Chart         *ChartFragment                 "json:\"chart\" graphql:\"chart\""
	Terraform     *TerraformFragment             "json:\"terraform\" graphql:\"terraform\""
	Configuration []*RecipeConfigurationFragment "json:\"configuration\" graphql:\"configuration\""
}
type RecipeConfigurationFragment struct {
	Name          *string   "json:\"name\" graphql:\"name\""
	Type          *Datatype "json:\"type\" graphql:\"type\""
	Default       *string   "json:\"default\" graphql:\"default\""
	Documentation *string   "json:\"documentation\" graphql:\"documentation\""
	Optional      *bool     "json:\"optional\" graphql:\"optional\""
	Placeholder   *string   "json:\"placeholder\" graphql:\"placeholder\""
	FunctionName  *string   "json:\"functionName\" graphql:\"functionName\""
	Condition     *struct {
		Field     string    "json:\"field\" graphql:\"field\""
		Operation Operation "json:\"operation\" graphql:\"operation\""
		Value     *string   "json:\"value\" graphql:\"value\""
	} "json:\"condition\" graphql:\"condition\""
	Validation *struct {
		Type    ValidationType "json:\"type\" graphql:\"type\""
		Regex   *string        "json:\"regex\" graphql:\"regex\""
		Message string         "json:\"message\" graphql:\"message\""
	} "json:\"validation\" graphql:\"validation\""
}
type RepositoryFragment struct {
	ID          string  "json:\"id\" graphql:\"id\""
	Name        string  "json:\"name\" graphql:\"name\""
	Notes       *string "json:\"notes\" graphql:\"notes\""
	Icon        *string "json:\"icon\" graphql:\"icon\""
	DarkIcon    *string "json:\"darkIcon\" graphql:\"darkIcon\""
	Description *string "json:\"description\" graphql:\"description\""
	Publisher   *struct {
		Name string "json:\"name\" graphql:\"name\""
	} "json:\"publisher\" graphql:\"publisher\""
	Recipes []*struct {
		Name string "json:\"name\" graphql:\"name\""
	} "json:\"recipes\" graphql:\"recipes\""
}
type TerraformFragment struct {
	ID             *string               "json:\"id\" graphql:\"id\""
	Name           *string               "json:\"name\" graphql:\"name\""
	Package        *string               "json:\"package\" graphql:\"package\""
	Description    *string               "json:\"description\" graphql:\"description\""
	Dependencies   *DependenciesFragment "json:\"dependencies\" graphql:\"dependencies\""
	ValuesTemplate *string               "json:\"valuesTemplate\" graphql:\"valuesTemplate\""
}
type TerraformInstallationFragment struct {
	ID        *string            "json:\"id\" graphql:\"id\""
	Terraform *TerraformFragment "json:\"terraform\" graphql:\"terraform\""
	Version   *VersionFragment   "json:\"version\" graphql:\"version\""
}
type VersionFragment struct {
	ID             string                "json:\"id\" graphql:\"id\""
	Readme         *string               "json:\"readme\" graphql:\"readme\""
	Version        string                "json:\"version\" graphql:\"version\""
	ValuesTemplate *string               "json:\"valuesTemplate\" graphql:\"valuesTemplate\""
	Package        *string               "json:\"package\" graphql:\"package\""
	Crds           []*CrdFragment        "json:\"crds\" graphql:\"crds\""
	Dependencies   *DependenciesFragment "json:\"dependencies\" graphql:\"dependencies\""
}
type CrdFragment struct {
	ID   string  "json:\"id\" graphql:\"id\""
	Name string  "json:\"name\" graphql:\"name\""
	Blob *string "json:\"blob\" graphql:\"blob\""
}
type ChartInstallationFragment struct {
	ID    *string "json:\"id\" graphql:\"id\""
	Chart *struct {
		ID            *string               "json:\"id\" graphql:\"id\""
		Name          string                "json:\"name\" graphql:\"name\""
		Description   *string               "json:\"description\" graphql:\"description\""
		LatestVersion *string               "json:\"latestVersion\" graphql:\"latestVersion\""
		Dependencies  *DependenciesFragment "json:\"dependencies\" graphql:\"dependencies\""
	} "json:\"chart\" graphql:\"chart\""
	Version *VersionFragment "json:\"version\" graphql:\"version\""
}
type InstallationFragment struct {
	ID           string                 "json:\"id\" graphql:\"id\""
	Context      map[string]interface{} "json:\"context\" graphql:\"context\""
	LicenseKey   *string                "json:\"licenseKey\" graphql:\"licenseKey\""
	AcmeKeyID    *string                "json:\"acmeKeyId\" graphql:\"acmeKeyId\""
	AcmeSecret   *string                "json:\"acmeSecret\" graphql:\"acmeSecret\""
	Repository   *RepositoryFragment    "json:\"repository\" graphql:\"repository\""
	OidcProvider *OIDCProvider          "json:\"oidcProvider\" graphql:\"oidcProvider\""
}
type OIDCProvider struct {
	ID           string    "json:\"id\" graphql:\"id\""
	ClientID     string    "json:\"clientId\" graphql:\"clientId\""
	ClientSecret string    "json:\"clientSecret\" graphql:\"clientSecret\""
	RedirectUris []*string "json:\"redirectUris\" graphql:\"redirectUris\""
	Bindings     []*struct {
		User *struct {
			ID    string "json:\"id\" graphql:\"id\""
			Email string "json:\"email\" graphql:\"email\""
		} "json:\"user\" graphql:\"user\""
		Group *struct {
			ID   string "json:\"id\" graphql:\"id\""
			Name string "json:\"name\" graphql:\"name\""
		} "json:\"group\" graphql:\"group\""
	} "json:\"bindings\" graphql:\"bindings\""
	Configuration *struct {
		Issuer                *string "json:\"issuer\" graphql:\"issuer\""
		AuthorizationEndpoint *string "json:\"authorizationEndpoint\" graphql:\"authorizationEndpoint\""
		TokenEndpoint         *string "json:\"tokenEndpoint\" graphql:\"tokenEndpoint\""
		JwksURI               *string "json:\"jwksUri\" graphql:\"jwksUri\""
		UserinfoEndpoint      *string "json:\"userinfoEndpoint\" graphql:\"userinfoEndpoint\""
	} "json:\"configuration\" graphql:\"configuration\""
}
type PublicKeyFragment struct {
	ID      string       "json:\"id\" graphql:\"id\""
	Content string       "json:\"content\" graphql:\"content\""
	User    UserFragment "json:\"user\" graphql:\"user\""
}
type UserFragment struct {
	ID    string "json:\"id\" graphql:\"id\""
	Name  string "json:\"name\" graphql:\"name\""
	Email string "json:\"email\" graphql:\"email\""
}
type EabCredentialFragment struct {
	ID       string   "json:\"id\" graphql:\"id\""
	KeyID    string   "json:\"keyId\" graphql:\"keyId\""
	HmacKey  string   "json:\"hmacKey\" graphql:\"hmacKey\""
	Cluster  string   "json:\"cluster\" graphql:\"cluster\""
	Provider Provider "json:\"provider\" graphql:\"provider\""
}
type TestFragment struct {
	ID         string     "json:\"id\" graphql:\"id\""
	Name       *string    "json:\"name\" graphql:\"name\""
	Status     TestStatus "json:\"status\" graphql:\"status\""
	PromoteTag string     "json:\"promoteTag\" graphql:\"promoteTag\""
	Steps      []*struct {
		ID          string     "json:\"id\" graphql:\"id\""
		Name        string     "json:\"name\" graphql:\"name\""
		Description string     "json:\"description\" graphql:\"description\""
		Status      TestStatus "json:\"status\" graphql:\"status\""
	} "json:\"steps\" graphql:\"steps\""
}
type StackFragment struct {
	ID          string            "json:\"id\" graphql:\"id\""
	Name        string            "json:\"name\" graphql:\"name\""
	Featured    *bool             "json:\"featured\" graphql:\"featured\""
	Description *string           "json:\"description\" graphql:\"description\""
	Bundles     []*RecipeFragment "json:\"bundles\" graphql:\"bundles\""
}
type KeyBackupFragment struct {
	ID           string    "json:\"id\" graphql:\"id\""
	Name         string    "json:\"name\" graphql:\"name\""
	Repositories []*string "json:\"repositories\" graphql:\"repositories\""
}
type ListArtifacts struct {
	Repository *struct {
		Artifacts []*ArtifactFragment "json:\"artifacts\" graphql:\"artifacts\""
	} "json:\"repository\" graphql:\"repository\""
}
type CreateArtifact struct {
	CreateArtifact *ArtifactFragment "json:\"createArtifact\" graphql:\"createArtifact\""
}
type GetCharts struct {
	Charts *struct {
		Edges []*struct {
			Node *ChartFragment "json:\"node\" graphql:\"node\""
		} "json:\"edges\" graphql:\"edges\""
	} "json:\"charts\" graphql:\"charts\""
}
type GetVersions struct {
	Versions *struct {
		Edges []*struct {
			Node *VersionFragment "json:\"node\" graphql:\"node\""
		} "json:\"edges\" graphql:\"edges\""
	} "json:\"versions\" graphql:\"versions\""
}
type GetChartInstallations struct {
	ChartInstallations *struct {
		Edges []*struct {
			Node *ChartInstallationFragment "json:\"node\" graphql:\"node\""
		} "json:\"edges\" graphql:\"edges\""
	} "json:\"chartInstallations\" graphql:\"chartInstallations\""
}
type GetPackageInstallations struct {
	ChartInstallations *struct {
		Edges []*struct {
			Node *ChartInstallationFragment "json:\"node\" graphql:\"node\""
		} "json:\"edges\" graphql:\"edges\""
	} "json:\"chartInstallations\" graphql:\"chartInstallations\""
	TerraformInstallations *struct {
		Edges []*struct {
			Node *TerraformInstallationFragment "json:\"node\" graphql:\"node\""
		} "json:\"edges\" graphql:\"edges\""
	} "json:\"terraformInstallations\" graphql:\"terraformInstallations\""
}
type CreateCrd struct {
	CreateCrd *struct {
		ID string "json:\"id\" graphql:\"id\""
	} "json:\"createCrd\" graphql:\"createCrd\""
}
type UninstallChart struct {
	DeleteChartInstallation *struct {
		ID *string "json:\"id\" graphql:\"id\""
	} "json:\"deleteChartInstallation\" graphql:\"deleteChartInstallation\""
}
type GetDNSRecords struct {
	DNSRecords *struct {
		Edges []*struct {
			Node *DNSRecordFragment "json:\"node\" graphql:\"node\""
		} "json:\"edges\" graphql:\"edges\""
	} "json:\"dnsRecords\" graphql:\"dnsRecords\""
}
type CreateDNSRecord struct {
	CreateDNSRecord *DNSRecordFragment "json:\"createDnsRecord\" graphql:\"createDnsRecord\""
}
type DeleteDNSRecord struct {
	DeleteDNSRecord *DNSRecordFragment "json:\"deleteDnsRecord\" graphql:\"deleteDnsRecord\""
}
type CreateDomain struct {
	ProvisionDomain *DNSDomainFragment "json:\"provisionDomain\" graphql:\"provisionDomain\""
}
type GetInstallation struct {
	Installation *InstallationFragment "json:\"installation\" graphql:\"installation\""
}
type GetInstallationByID struct {
	Installation *InstallationFragment "json:\"installation\" graphql:\"installation\""
}
type GetInstallations struct {
	Installations *struct {
		Edges []*struct {
			Node *InstallationFragment "json:\"node\" graphql:\"node\""
		} "json:\"edges\" graphql:\"edges\""
	} "json:\"installations\" graphql:\"installations\""
}
type UpsertOidcProvider struct {
	UpsertOidcProvider *struct {
		ID string "json:\"id\" graphql:\"id\""
	} "json:\"upsertOidcProvider\" graphql:\"upsertOidcProvider\""
}
type ResetInstallations struct {
	ResetInstallations *int64 "json:\"resetInstallations\" graphql:\"resetInstallations\""
}
type DeleteInstallation struct {
	DeleteInstallation *struct {
		ID string "json:\"id\" graphql:\"id\""
	} "json:\"deleteInstallation\" graphql:\"deleteInstallation\""
}
type GetRecipe struct {
	Recipe *struct {
		ID          string    "json:\"id\" graphql:\"id\""
		Name        string    "json:\"name\" graphql:\"name\""
		Description *string   "json:\"description\" graphql:\"description\""
		Restricted  *bool     "json:\"restricted\" graphql:\"restricted\""
		Provider    *Provider "json:\"provider\" graphql:\"provider\""
		Tests       []*struct {
			Type    TestType "json:\"type\" graphql:\"type\""
			Name    string   "json:\"name\" graphql:\"name\""
			Message *string  "json:\"message\" graphql:\"message\""
			Args    []*struct {
				Name string "json:\"name\" graphql:\"name\""
				Repo string "json:\"repo\" graphql:\"repo\""
				Key  string "json:\"key\" graphql:\"key\""
			} "json:\"args\" graphql:\"args\""
		} "json:\"tests\" graphql:\"tests\""
		Repository *struct {
			ID   string "json:\"id\" graphql:\"id\""
			Name string "json:\"name\" graphql:\"name\""
		} "json:\"repository\" graphql:\"repository\""
		OidcSettings *struct {
			URIFormat  *string        "json:\"uriFormat\" graphql:\"uriFormat\""
			URIFormats []*string      "json:\"uriFormats\" graphql:\"uriFormats\""
			AuthMethod OidcAuthMethod "json:\"authMethod\" graphql:\"authMethod\""
			DomainKey  *string        "json:\"domainKey\" graphql:\"domainKey\""
			Subdomain  *bool          "json:\"subdomain\" graphql:\"subdomain\""
		} "json:\"oidcSettings\" graphql:\"oidcSettings\""
		RecipeSections     []*RecipeSectionFragment "json:\"recipeSections\" graphql:\"recipeSections\""
		RecipeDependencies []*RecipeFragment        "json:\"recipeDependencies\" graphql:\"recipeDependencies\""
	} "json:\"recipe\" graphql:\"recipe\""
}
type ListRecipes struct {
	Recipes *struct {
		Edges []*struct {
			Node *RecipeFragment "json:\"node\" graphql:\"node\""
		} "json:\"edges\" graphql:\"edges\""
	} "json:\"recipes\" graphql:\"recipes\""
}
type ListAllRecipes struct {
	Recipes *struct {
		Edges []*struct {
			Node *RecipeFragment "json:\"node\" graphql:\"node\""
		} "json:\"edges\" graphql:\"edges\""
	} "json:\"recipes\" graphql:\"recipes\""
}
type CreateRecipe struct {
	CreateRecipe *struct {
		ID string "json:\"id\" graphql:\"id\""
	} "json:\"createRecipe\" graphql:\"createRecipe\""
}
type InstallRecipe struct {
	InstallRecipe []*struct {
		ID string "json:\"id\" graphql:\"id\""
	} "json:\"installRecipe\" graphql:\"installRecipe\""
}
type CreateStack struct {
	CreateStack *struct {
		ID string "json:\"id\" graphql:\"id\""
	} "json:\"createStack\" graphql:\"createStack\""
}
type GetStack struct {
	Stack *StackFragment "json:\"stack\" graphql:\"stack\""
}
type ListStacks struct {
	Stacks *struct {
		Edges []*struct {
			Node *StackFragment "json:\"node\" graphql:\"node\""
		} "json:\"edges\" graphql:\"edges\""
	} "json:\"stacks\" graphql:\"stacks\""
}
type GetRepository struct {
	Repository *RepositoryFragment "json:\"repository\" graphql:\"repository\""
}
type CreateResourceDefinition struct {
	UpdateRepository *struct {
		ID string "json:\"id\" graphql:\"id\""
	} "json:\"updateRepository\" graphql:\"updateRepository\""
}
type CreateIntegration struct {
	CreateIntegration *struct {
		ID string "json:\"id\" graphql:\"id\""
	} "json:\"createIntegration\" graphql:\"createIntegration\""
}
type UpdateRepository struct {
	UpdateRepository *struct {
		ID string "json:\"id\" graphql:\"id\""
	} "json:\"updateRepository\" graphql:\"updateRepository\""
}
type CreateRepository struct {
	UpsertRepository *struct {
		ID string "json:\"id\" graphql:\"id\""
	} "json:\"upsertRepository\" graphql:\"upsertRepository\""
}
type AcquireLock struct {
	AcquireLock *ApplyLockFragment "json:\"acquireLock\" graphql:\"acquireLock\""
}
type ReleaseLock struct {
	ReleaseLock *ApplyLockFragment "json:\"releaseLock\" graphql:\"releaseLock\""
}
type UnlockRepository struct {
	UnlockRepository *int64 "json:\"unlockRepository\" graphql:\"unlockRepository\""
}
type ListRepositories struct {
	Repositories *struct {
		Edges []*struct {
			Node *RepositoryFragment "json:\"node\" graphql:\"node\""
		} "json:\"edges\" graphql:\"edges\""
	} "json:\"repositories\" graphql:\"repositories\""
}
type Scaffolds struct {
	Scaffold []*struct {
		Path    *string "json:\"path\" graphql:\"path\""
		Content *string "json:\"content\" graphql:\"content\""
	} "json:\"scaffold\" graphql:\"scaffold\""
}
type DeleteRepository struct {
	DeleteRepository *struct {
		ID string "json:\"id\" graphql:\"id\""
	} "json:\"deleteRepository\" graphql:\"deleteRepository\""
}
type GetTfProviders struct {
	TerraformProviders []*Provider "json:\"terraformProviders\" graphql:\"terraformProviders\""
}
type GetTfProviderScaffold struct {
	TerraformProvider *struct {
		Name    *Provider "json:\"name\" graphql:\"name\""
		Content *string   "json:\"content\" graphql:\"content\""
	} "json:\"terraformProvider\" graphql:\"terraformProvider\""
}
type GetShell struct {
	Shell *CloudShellFragment "json:\"shell\" graphql:\"shell\""
}
type DeleteShell struct {
	DeleteShell *CloudShellFragment "json:\"deleteShell\" graphql:\"deleteShell\""
}
type GetTerraform struct {
	Terraform *struct {
		Edges []*struct {
			Node *TerraformFragment "json:\"node\" graphql:\"node\""
		} "json:\"edges\" graphql:\"edges\""
	} "json:\"terraform\" graphql:\"terraform\""
}
type GetTerraformInstallations struct {
	TerraformInstallations *struct {
		Edges []*struct {
			Node *TerraformInstallationFragment "json:\"node\" graphql:\"node\""
		} "json:\"edges\" graphql:\"edges\""
	} "json:\"terraformInstallations\" graphql:\"terraformInstallations\""
}
type UploadTerraform struct {
	UploadTerraform *TerraformFragment "json:\"uploadTerraform\" graphql:\"uploadTerraform\""
}
type UninstallTerraform struct {
	UninstallTerraform *struct {
		ID *string "json:\"id\" graphql:\"id\""
	} "json:\"uninstallTerraform\" graphql:\"uninstallTerraform\""
}
type CreateTest struct {
	CreateTest *TestFragment "json:\"createTest\" graphql:\"createTest\""
}
type UpdateTest struct {
	UpdateTest *TestFragment "json:\"updateTest\" graphql:\"updateTest\""
}
type UpdateStep struct {
	UpdateStep *struct {
		ID string "json:\"id\" graphql:\"id\""
	} "json:\"updateStep\" graphql:\"updateStep\""
}
type PublishLogs struct {
	PublishLogs *struct {
		ID string "json:\"id\" graphql:\"id\""
	} "json:\"publishLogs\" graphql:\"publishLogs\""
}
type Me struct {
	Me *struct {
		ID    string "json:\"id\" graphql:\"id\""
		Email string "json:\"email\" graphql:\"email\""
	} "json:\"me\" graphql:\"me\""
}
type GetLoginMethod struct {
	LoginMethod *struct {
		LoginMethod LoginMethod "json:\"loginMethod\" graphql:\"loginMethod\""
		Token       *string     "json:\"token\" graphql:\"token\""
	} "json:\"loginMethod\" graphql:\"loginMethod\""
}
type ListTokens struct {
	Tokens *struct {
		Edges []*struct {
			Node *struct {
				Token *string "json:\"token\" graphql:\"token\""
			} "json:\"node\" graphql:\"node\""
		} "json:\"edges\" graphql:\"edges\""
	} "json:\"tokens\" graphql:\"tokens\""
}
type ListKeys struct {
	PublicKeys *struct {
		Edges []*struct {
			Node *PublicKeyFragment "json:\"node\" graphql:\"node\""
		} "json:\"edges\" graphql:\"edges\""
	} "json:\"publicKeys\" graphql:\"publicKeys\""
}
type GetEabCredential struct {
	EabCredential *EabCredentialFragment "json:\"eabCredential\" graphql:\"eabCredential\""
}
type PollLoginToken struct {
	LoginToken *struct {
		Jwt *string "json:\"jwt\" graphql:\"jwt\""
	} "json:\"loginToken\" graphql:\"loginToken\""
}
type DevLogin struct {
	DeviceLogin *struct {
		LoginURL    string "json:\"loginUrl\" graphql:\"loginUrl\""
		DeviceToken string "json:\"deviceToken\" graphql:\"deviceToken\""
	} "json:\"deviceLogin\" graphql:\"deviceLogin\""
}
type Login struct {
	Login *struct {
		Jwt *string "json:\"jwt\" graphql:\"jwt\""
	} "json:\"login\" graphql:\"login\""
}
type ImpersonateServiceAccount struct {
	ImpersonateServiceAccount *struct {
		Jwt   *string "json:\"jwt\" graphql:\"jwt\""
		Email string  "json:\"email\" graphql:\"email\""
	} "json:\"impersonateServiceAccount\" graphql:\"impersonateServiceAccount\""
}
type CreateAccessToken struct {
	CreateToken *struct {
		Token *string "json:\"token\" graphql:\"token\""
	} "json:\"createToken\" graphql:\"createToken\""
}
type CreateKey struct {
	CreatePublicKey *struct {
		ID string "json:\"id\" graphql:\"id\""
	} "json:\"createPublicKey\" graphql:\"createPublicKey\""
}
type DeleteEabCredential struct {
	DeleteEabKey *struct {
		ID string "json:\"id\" graphql:\"id\""
	} "json:\"deleteEabKey\" graphql:\"deleteEabKey\""
}
type CreateEvent struct {
	CreateUserEvent *bool "json:\"createUserEvent\" graphql:\"createUserEvent\""
}
type CreateBackup struct {
	CreateKeyBackup *KeyBackupFragment "json:\"createKeyBackup\" graphql:\"createKeyBackup\""
}
type Backups struct {
	KeyBackups *struct {
		Edges []*struct {
			Node *KeyBackupFragment "json:\"node\" graphql:\"node\""
		} "json:\"edges\" graphql:\"edges\""
	} "json:\"keyBackups\" graphql:\"keyBackups\""
}
type Backup struct {
	KeyBackup *struct {
		ID           string    "json:\"id\" graphql:\"id\""
		Name         string    "json:\"name\" graphql:\"name\""
		Repositories []*string "json:\"repositories\" graphql:\"repositories\""
		Value        string    "json:\"value\" graphql:\"value\""
	} "json:\"keyBackup\" graphql:\"keyBackup\""
}
type GetHelp struct {
	HelpQuestion *string "json:\"helpQuestion\" graphql:\"helpQuestion\""
}
type UpdateVersion struct {
	UpdateVersion *struct {
		ID string "json:\"id\" graphql:\"id\""
	} "json:\"updateVersion\" graphql:\"updateVersion\""
}

const ListArtifactsDocument = `query ListArtifacts ($id: ID!) {
	repository(id: $id) {
		artifacts {
			... ArtifactFragment
		}
	}
}
fragment ArtifactFragment on Artifact {
	id
	name
	readme
	platform
	arch
	blob
	sha
	filesize
}
`

func (c *Client) ListArtifacts(ctx context.Context, id string, httpRequestOptions ...client.HTTPRequestOption) (*ListArtifacts, error) {
	vars := map[string]interface{}{
		"id": id,
	}

	var res ListArtifacts
	if err := c.Client.Post(ctx, "ListArtifacts", ListArtifactsDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const CreateArtifactDocument = `mutation CreateArtifact ($repoName: String!, $name: String!, $readme: String!, $artifactType: String!, $platform: String!, $blob: UploadOrUrl!, $arch: String) {
	createArtifact(repositoryName: $repoName, attributes: {name:$name,blob:$blob,readme:$readme,type:$artifactType,platform:$platform,arch:$arch}) {
		... ArtifactFragment
	}
}
fragment ArtifactFragment on Artifact {
	id
	name
	readme
	platform
	arch
	blob
	sha
	filesize
}
`

func (c *Client) CreateArtifact(ctx context.Context, repoName string, name string, readme string, artifactType string, platform string, blob string, arch *string, httpRequestOptions ...client.HTTPRequestOption) (*CreateArtifact, error) {
	vars := map[string]interface{}{
		"repoName":     repoName,
		"name":         name,
		"readme":       readme,
		"artifactType": artifactType,
		"platform":     platform,
		"blob":         blob,
		"arch":         arch,
	}

	var res CreateArtifact
	if err := c.Client.Post(ctx, "CreateArtifact", CreateArtifactDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const GetChartsDocument = `query GetCharts ($id: ID!) {
	charts(repositoryId: $id, first: 100) {
		edges {
			node {
				... ChartFragment
			}
		}
	}
}
fragment ChartFragment on Chart {
	id
	name
	description
	latestVersion
}
`

func (c *Client) GetCharts(ctx context.Context, id string, httpRequestOptions ...client.HTTPRequestOption) (*GetCharts, error) {
	vars := map[string]interface{}{
		"id": id,
	}

	var res GetCharts
	if err := c.Client.Post(ctx, "GetCharts", GetChartsDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const GetVersionsDocument = `query GetVersions ($id: ID!) {
	versions(chartId: $id, first: 100) {
		edges {
			node {
				... VersionFragment
			}
		}
	}
}
fragment VersionFragment on Version {
	id
	readme
	version
	valuesTemplate
	package
	crds {
		... CrdFragment
	}
	dependencies {
		... DependenciesFragment
	}
}
fragment CrdFragment on Crd {
	id
	name
	blob
}
fragment DependenciesFragment on Dependencies {
	dependencies {
		type
		name
		repo
	}
	wait
	application
	providers
	secrets
	wirings {
		terraform
		helm
	}
	providerWirings
	outputs
	providerVsn
}
`

func (c *Client) GetVersions(ctx context.Context, id string, httpRequestOptions ...client.HTTPRequestOption) (*GetVersions, error) {
	vars := map[string]interface{}{
		"id": id,
	}

	var res GetVersions
	if err := c.Client.Post(ctx, "GetVersions", GetVersionsDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const GetChartInstallationsDocument = `query GetChartInstallations ($id: ID!) {
	chartInstallations(repositoryId: $id, first: 100) {
		edges {
			node {
				... ChartInstallationFragment
			}
		}
	}
}
fragment VersionFragment on Version {
	id
	readme
	version
	valuesTemplate
	package
	crds {
		... CrdFragment
	}
	dependencies {
		... DependenciesFragment
	}
}
fragment CrdFragment on Crd {
	id
	name
	blob
}
fragment ChartInstallationFragment on ChartInstallation {
	id
	chart {
		... ChartFragment
		dependencies {
			... DependenciesFragment
		}
	}
	version {
		... VersionFragment
	}
}
fragment ChartFragment on Chart {
	id
	name
	description
	latestVersion
}
fragment DependenciesFragment on Dependencies {
	dependencies {
		type
		name
		repo
	}
	wait
	application
	providers
	secrets
	wirings {
		terraform
		helm
	}
	providerWirings
	outputs
	providerVsn
}
`

func (c *Client) GetChartInstallations(ctx context.Context, id string, httpRequestOptions ...client.HTTPRequestOption) (*GetChartInstallations, error) {
	vars := map[string]interface{}{
		"id": id,
	}

	var res GetChartInstallations
	if err := c.Client.Post(ctx, "GetChartInstallations", GetChartInstallationsDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const GetPackageInstallationsDocument = `query GetPackageInstallations ($id: ID!) {
	chartInstallations(repositoryId: $id, first: 100) {
		edges {
			node {
				... ChartInstallationFragment
			}
		}
	}
	terraformInstallations(repositoryId: $id, first: 100) {
		edges {
			node {
				... TerraformInstallationFragment
			}
		}
	}
}
fragment TerraformFragment on Terraform {
	id
	name
	package
	description
	dependencies {
		... DependenciesFragment
	}
	valuesTemplate
}
fragment ChartInstallationFragment on ChartInstallation {
	id
	chart {
		... ChartFragment
		dependencies {
			... DependenciesFragment
		}
	}
	version {
		... VersionFragment
	}
}
fragment ChartFragment on Chart {
	id
	name
	description
	latestVersion
}
fragment DependenciesFragment on Dependencies {
	dependencies {
		type
		name
		repo
	}
	wait
	application
	providers
	secrets
	wirings {
		terraform
		helm
	}
	providerWirings
	outputs
	providerVsn
}
fragment VersionFragment on Version {
	id
	readme
	version
	valuesTemplate
	package
	crds {
		... CrdFragment
	}
	dependencies {
		... DependenciesFragment
	}
}
fragment CrdFragment on Crd {
	id
	name
	blob
}
fragment TerraformInstallationFragment on TerraformInstallation {
	id
	terraform {
		... TerraformFragment
	}
	version {
		... VersionFragment
	}
}
`

func (c *Client) GetPackageInstallations(ctx context.Context, id string, httpRequestOptions ...client.HTTPRequestOption) (*GetPackageInstallations, error) {
	vars := map[string]interface{}{
		"id": id,
	}

	var res GetPackageInstallations
	if err := c.Client.Post(ctx, "GetPackageInstallations", GetPackageInstallationsDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const CreateCrdDocument = `mutation CreateCrd ($chartName: ChartName!, $name: String!, $blob: UploadOrUrl!) {
	createCrd(chartName: $chartName, attributes: {name:$name,blob:$blob}) {
		id
	}
}
`

func (c *Client) CreateCrd(ctx context.Context, chartName ChartName, name string, blob string, httpRequestOptions ...client.HTTPRequestOption) (*CreateCrd, error) {
	vars := map[string]interface{}{
		"chartName": chartName,
		"name":      name,
		"blob":      blob,
	}

	var res CreateCrd
	if err := c.Client.Post(ctx, "CreateCrd", CreateCrdDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const UninstallChartDocument = `mutation UninstallChart ($id: ID!) {
	deleteChartInstallation(id: $id) {
		id
	}
}
`

func (c *Client) UninstallChart(ctx context.Context, id string, httpRequestOptions ...client.HTTPRequestOption) (*UninstallChart, error) {
	vars := map[string]interface{}{
		"id": id,
	}

	var res UninstallChart
	if err := c.Client.Post(ctx, "UninstallChart", UninstallChartDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const GetDNSRecordsDocument = `query GetDnsRecords ($cluster: String!, $provider: Provider!) {
	dnsRecords(cluster: $cluster, provider: $provider, first: 500) {
		edges {
			node {
				... DnsRecordFragment
			}
		}
	}
}
fragment DnsRecordFragment on DnsRecord {
	type
	name
	records
}
`

func (c *Client) GetDNSRecords(ctx context.Context, cluster string, provider Provider, httpRequestOptions ...client.HTTPRequestOption) (*GetDNSRecords, error) {
	vars := map[string]interface{}{
		"cluster":  cluster,
		"provider": provider,
	}

	var res GetDNSRecords
	if err := c.Client.Post(ctx, "GetDnsRecords", GetDNSRecordsDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const CreateDNSRecordDocument = `mutation CreateDnsRecord ($cluster: String!, $provider: Provider!, $attributes: DnsRecordAttributes!) {
	createDnsRecord(cluster: $cluster, provider: $provider, attributes: $attributes) {
		... DnsRecordFragment
	}
}
fragment DnsRecordFragment on DnsRecord {
	type
	name
	records
}
`

func (c *Client) CreateDNSRecord(ctx context.Context, cluster string, provider Provider, attributes DNSRecordAttributes, httpRequestOptions ...client.HTTPRequestOption) (*CreateDNSRecord, error) {
	vars := map[string]interface{}{
		"cluster":    cluster,
		"provider":   provider,
		"attributes": attributes,
	}

	var res CreateDNSRecord
	if err := c.Client.Post(ctx, "CreateDnsRecord", CreateDNSRecordDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const DeleteDNSRecordDocument = `mutation DeleteDnsRecord ($name: String!, $type: DnsRecordType!) {
	deleteDnsRecord(name: $name, type: $type) {
		... DnsRecordFragment
	}
}
fragment DnsRecordFragment on DnsRecord {
	type
	name
	records
}
`

func (c *Client) DeleteDNSRecord(ctx context.Context, name string, typeArg DNSRecordType, httpRequestOptions ...client.HTTPRequestOption) (*DeleteDNSRecord, error) {
	vars := map[string]interface{}{
		"name": name,
		"type": typeArg,
	}

	var res DeleteDNSRecord
	if err := c.Client.Post(ctx, "DeleteDnsRecord", DeleteDNSRecordDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const CreateDomainDocument = `mutation CreateDomain ($name: String!) {
	provisionDomain(name: $name) {
		... DnsDomainFragment
	}
}
fragment DnsDomainFragment on DnsDomain {
	id
	name
}
`

func (c *Client) CreateDomain(ctx context.Context, name string, httpRequestOptions ...client.HTTPRequestOption) (*CreateDomain, error) {
	vars := map[string]interface{}{
		"name": name,
	}

	var res CreateDomain
	if err := c.Client.Post(ctx, "CreateDomain", CreateDomainDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const GetInstallationDocument = `query GetInstallation ($name: String) {
	installation(name: $name) {
		... InstallationFragment
	}
}
fragment InstallationFragment on Installation {
	id
	context
	licenseKey
	acmeKeyId
	acmeSecret
	repository {
		... RepositoryFragment
	}
	oidcProvider {
		... OIDCProvider
	}
}
fragment RepositoryFragment on Repository {
	id
	name
	notes
	icon
	darkIcon
	description
	publisher {
		name
	}
	recipes {
		name
	}
}
fragment OIDCProvider on OidcProvider {
	id
	clientId
	clientSecret
	redirectUris
	bindings {
		user {
			id
			email
		}
		group {
			id
			name
		}
	}
	configuration {
		issuer
		authorizationEndpoint
		tokenEndpoint
		jwksUri
		userinfoEndpoint
	}
}
`

func (c *Client) GetInstallation(ctx context.Context, name *string, httpRequestOptions ...client.HTTPRequestOption) (*GetInstallation, error) {
	vars := map[string]interface{}{
		"name": name,
	}

	var res GetInstallation
	if err := c.Client.Post(ctx, "GetInstallation", GetInstallationDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const GetInstallationByIDDocument = `query GetInstallationById ($id: ID) {
	installation(id: $id) {
		... InstallationFragment
	}
}
fragment InstallationFragment on Installation {
	id
	context
	licenseKey
	acmeKeyId
	acmeSecret
	repository {
		... RepositoryFragment
	}
	oidcProvider {
		... OIDCProvider
	}
}
fragment RepositoryFragment on Repository {
	id
	name
	notes
	icon
	darkIcon
	description
	publisher {
		name
	}
	recipes {
		name
	}
}
fragment OIDCProvider on OidcProvider {
	id
	clientId
	clientSecret
	redirectUris
	bindings {
		user {
			id
			email
		}
		group {
			id
			name
		}
	}
	configuration {
		issuer
		authorizationEndpoint
		tokenEndpoint
		jwksUri
		userinfoEndpoint
	}
}
`

func (c *Client) GetInstallationByID(ctx context.Context, id *string, httpRequestOptions ...client.HTTPRequestOption) (*GetInstallationByID, error) {
	vars := map[string]interface{}{
		"id": id,
	}

	var res GetInstallationByID
	if err := c.Client.Post(ctx, "GetInstallationById", GetInstallationByIDDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const GetInstallationsDocument = `query GetInstallations {
	installations(first: 100) {
		edges {
			node {
				... InstallationFragment
			}
		}
	}
}
fragment InstallationFragment on Installation {
	id
	context
	licenseKey
	acmeKeyId
	acmeSecret
	repository {
		... RepositoryFragment
	}
	oidcProvider {
		... OIDCProvider
	}
}
fragment RepositoryFragment on Repository {
	id
	name
	notes
	icon
	darkIcon
	description
	publisher {
		name
	}
	recipes {
		name
	}
}
fragment OIDCProvider on OidcProvider {
	id
	clientId
	clientSecret
	redirectUris
	bindings {
		user {
			id
			email
		}
		group {
			id
			name
		}
	}
	configuration {
		issuer
		authorizationEndpoint
		tokenEndpoint
		jwksUri
		userinfoEndpoint
	}
}
`

func (c *Client) GetInstallations(ctx context.Context, httpRequestOptions ...client.HTTPRequestOption) (*GetInstallations, error) {
	vars := map[string]interface{}{}

	var res GetInstallations
	if err := c.Client.Post(ctx, "GetInstallations", GetInstallationsDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const UpsertOidcProviderDocument = `mutation UpsertOidcProvider ($id: ID!, $attributes: OidcAttributes!) {
	upsertOidcProvider(installationId: $id, attributes: $attributes) {
		id
	}
}
`

func (c *Client) UpsertOidcProvider(ctx context.Context, id string, attributes OidcAttributes, httpRequestOptions ...client.HTTPRequestOption) (*UpsertOidcProvider, error) {
	vars := map[string]interface{}{
		"id":         id,
		"attributes": attributes,
	}

	var res UpsertOidcProvider
	if err := c.Client.Post(ctx, "UpsertOidcProvider", UpsertOidcProviderDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const ResetInstallationsDocument = `mutation ResetInstallations {
	resetInstallations
}
`

func (c *Client) ResetInstallations(ctx context.Context, httpRequestOptions ...client.HTTPRequestOption) (*ResetInstallations, error) {
	vars := map[string]interface{}{}

	var res ResetInstallations
	if err := c.Client.Post(ctx, "ResetInstallations", ResetInstallationsDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const DeleteInstallationDocument = `mutation DeleteInstallation ($id: ID!) {
	deleteInstallation(id: $id) {
		id
	}
}
`

func (c *Client) DeleteInstallation(ctx context.Context, id string, httpRequestOptions ...client.HTTPRequestOption) (*DeleteInstallation, error) {
	vars := map[string]interface{}{
		"id": id,
	}

	var res DeleteInstallation
	if err := c.Client.Post(ctx, "DeleteInstallation", DeleteInstallationDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const GetRecipeDocument = `query GetRecipe ($repo: String, $name: String) {
	recipe(repo: $repo, name: $name) {
		... RecipeFragment
		recipeDependencies {
			... RecipeFragment
		}
	}
}
fragment RepositoryFragment on Repository {
	id
	name
	notes
	icon
	darkIcon
	description
	publisher {
		name
	}
	recipes {
		name
	}
}
fragment RecipeItemFragment on RecipeItem {
	id
	chart {
		... ChartFragment
	}
	terraform {
		... TerraformFragment
	}
	configuration {
		... RecipeConfigurationFragment
	}
}
fragment ChartFragment on Chart {
	id
	name
	description
	latestVersion
}
fragment TerraformFragment on Terraform {
	id
	name
	package
	description
	dependencies {
		... DependenciesFragment
	}
	valuesTemplate
}
fragment DependenciesFragment on Dependencies {
	dependencies {
		type
		name
		repo
	}
	wait
	application
	providers
	secrets
	wirings {
		terraform
		helm
	}
	providerWirings
	outputs
	providerVsn
}
fragment RecipeConfigurationFragment on RecipeConfiguration {
	name
	type
	default
	documentation
	optional
	placeholder
	functionName
	condition {
		field
		operation
		value
	}
	validation {
		type
		regex
		message
	}
}
fragment RecipeFragment on Recipe {
	id
	name
	description
	restricted
	provider
	tests {
		type
		name
		message
		args {
			name
			repo
			key
		}
	}
	repository {
		id
		name
	}
	oidcSettings {
		uriFormat
		uriFormats
		authMethod
		domainKey
		subdomain
	}
	recipeSections {
		... RecipeSectionFragment
	}
}
fragment RecipeSectionFragment on RecipeSection {
	index
	repository {
		... RepositoryFragment
	}
	recipeItems {
		... RecipeItemFragment
	}
	configuration {
		... RecipeConfigurationFragment
	}
}
`

func (c *Client) GetRecipe(ctx context.Context, repo *string, name *string, httpRequestOptions ...client.HTTPRequestOption) (*GetRecipe, error) {
	vars := map[string]interface{}{
		"repo": repo,
		"name": name,
	}

	var res GetRecipe
	if err := c.Client.Post(ctx, "GetRecipe", GetRecipeDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const ListRecipesDocument = `query ListRecipes ($repo: String, $provider: Provider) {
	recipes(repositoryName: $repo, provider: $provider, first: 500) {
		edges {
			node {
				... RecipeFragment
			}
		}
	}
}
fragment RecipeFragment on Recipe {
	id
	name
	description
	restricted
	provider
	tests {
		type
		name
		message
		args {
			name
			repo
			key
		}
	}
	repository {
		id
		name
	}
	oidcSettings {
		uriFormat
		uriFormats
		authMethod
		domainKey
		subdomain
	}
	recipeSections {
		... RecipeSectionFragment
	}
}
fragment RecipeSectionFragment on RecipeSection {
	index
	repository {
		... RepositoryFragment
	}
	recipeItems {
		... RecipeItemFragment
	}
	configuration {
		... RecipeConfigurationFragment
	}
}
fragment RepositoryFragment on Repository {
	id
	name
	notes
	icon
	darkIcon
	description
	publisher {
		name
	}
	recipes {
		name
	}
}
fragment RecipeItemFragment on RecipeItem {
	id
	chart {
		... ChartFragment
	}
	terraform {
		... TerraformFragment
	}
	configuration {
		... RecipeConfigurationFragment
	}
}
fragment ChartFragment on Chart {
	id
	name
	description
	latestVersion
}
fragment TerraformFragment on Terraform {
	id
	name
	package
	description
	dependencies {
		... DependenciesFragment
	}
	valuesTemplate
}
fragment DependenciesFragment on Dependencies {
	dependencies {
		type
		name
		repo
	}
	wait
	application
	providers
	secrets
	wirings {
		terraform
		helm
	}
	providerWirings
	outputs
	providerVsn
}
fragment RecipeConfigurationFragment on RecipeConfiguration {
	name
	type
	default
	documentation
	optional
	placeholder
	functionName
	condition {
		field
		operation
		value
	}
	validation {
		type
		regex
		message
	}
}
`

func (c *Client) ListRecipes(ctx context.Context, repo *string, provider *Provider, httpRequestOptions ...client.HTTPRequestOption) (*ListRecipes, error) {
	vars := map[string]interface{}{
		"repo":     repo,
		"provider": provider,
	}

	var res ListRecipes
	if err := c.Client.Post(ctx, "ListRecipes", ListRecipesDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const ListAllRecipesDocument = `query ListAllRecipes ($repo: String) {
	recipes(repositoryName: $repo, first: 500) {
		edges {
			node {
				... RecipeFragment
			}
		}
	}
}
fragment RecipeItemFragment on RecipeItem {
	id
	chart {
		... ChartFragment
	}
	terraform {
		... TerraformFragment
	}
	configuration {
		... RecipeConfigurationFragment
	}
}
fragment ChartFragment on Chart {
	id
	name
	description
	latestVersion
}
fragment TerraformFragment on Terraform {
	id
	name
	package
	description
	dependencies {
		... DependenciesFragment
	}
	valuesTemplate
}
fragment DependenciesFragment on Dependencies {
	dependencies {
		type
		name
		repo
	}
	wait
	application
	providers
	secrets
	wirings {
		terraform
		helm
	}
	providerWirings
	outputs
	providerVsn
}
fragment RecipeConfigurationFragment on RecipeConfiguration {
	name
	type
	default
	documentation
	optional
	placeholder
	functionName
	condition {
		field
		operation
		value
	}
	validation {
		type
		regex
		message
	}
}
fragment RecipeFragment on Recipe {
	id
	name
	description
	restricted
	provider
	tests {
		type
		name
		message
		args {
			name
			repo
			key
		}
	}
	repository {
		id
		name
	}
	oidcSettings {
		uriFormat
		uriFormats
		authMethod
		domainKey
		subdomain
	}
	recipeSections {
		... RecipeSectionFragment
	}
}
fragment RecipeSectionFragment on RecipeSection {
	index
	repository {
		... RepositoryFragment
	}
	recipeItems {
		... RecipeItemFragment
	}
	configuration {
		... RecipeConfigurationFragment
	}
}
fragment RepositoryFragment on Repository {
	id
	name
	notes
	icon
	darkIcon
	description
	publisher {
		name
	}
	recipes {
		name
	}
}
`

func (c *Client) ListAllRecipes(ctx context.Context, repo *string, httpRequestOptions ...client.HTTPRequestOption) (*ListAllRecipes, error) {
	vars := map[string]interface{}{
		"repo": repo,
	}

	var res ListAllRecipes
	if err := c.Client.Post(ctx, "ListAllRecipes", ListAllRecipesDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const CreateRecipeDocument = `mutation CreateRecipe ($name: String!, $attributes: RecipeAttributes!) {
	createRecipe(repositoryName: $name, attributes: $attributes) {
		id
	}
}
`

func (c *Client) CreateRecipe(ctx context.Context, name string, attributes RecipeAttributes, httpRequestOptions ...client.HTTPRequestOption) (*CreateRecipe, error) {
	vars := map[string]interface{}{
		"name":       name,
		"attributes": attributes,
	}

	var res CreateRecipe
	if err := c.Client.Post(ctx, "CreateRecipe", CreateRecipeDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const InstallRecipeDocument = `mutation InstallRecipe ($id: ID!) {
	installRecipe(recipeId: $id, context: "{}") {
		id
	}
}
`

func (c *Client) InstallRecipe(ctx context.Context, id string, httpRequestOptions ...client.HTTPRequestOption) (*InstallRecipe, error) {
	vars := map[string]interface{}{
		"id": id,
	}

	var res InstallRecipe
	if err := c.Client.Post(ctx, "InstallRecipe", InstallRecipeDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const CreateStackDocument = `mutation CreateStack ($attributes: StackAttributes!) {
	createStack(attributes: $attributes) {
		id
	}
}
`

func (c *Client) CreateStack(ctx context.Context, attributes StackAttributes, httpRequestOptions ...client.HTTPRequestOption) (*CreateStack, error) {
	vars := map[string]interface{}{
		"attributes": attributes,
	}

	var res CreateStack
	if err := c.Client.Post(ctx, "CreateStack", CreateStackDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const GetStackDocument = `query GetStack ($name: String!, $provider: Provider!) {
	stack(name: $name, provider: $provider) {
		... StackFragment
	}
}
fragment RecipeFragment on Recipe {
	id
	name
	description
	restricted
	provider
	tests {
		type
		name
		message
		args {
			name
			repo
			key
		}
	}
	repository {
		id
		name
	}
	oidcSettings {
		uriFormat
		uriFormats
		authMethod
		domainKey
		subdomain
	}
	recipeSections {
		... RecipeSectionFragment
	}
}
fragment RecipeSectionFragment on RecipeSection {
	index
	repository {
		... RepositoryFragment
	}
	recipeItems {
		... RecipeItemFragment
	}
	configuration {
		... RecipeConfigurationFragment
	}
}
fragment ChartFragment on Chart {
	id
	name
	description
	latestVersion
}
fragment TerraformFragment on Terraform {
	id
	name
	package
	description
	dependencies {
		... DependenciesFragment
	}
	valuesTemplate
}
fragment StackFragment on Stack {
	id
	name
	featured
	description
	bundles {
		... RecipeFragment
	}
}
fragment RepositoryFragment on Repository {
	id
	name
	notes
	icon
	darkIcon
	description
	publisher {
		name
	}
	recipes {
		name
	}
}
fragment RecipeItemFragment on RecipeItem {
	id
	chart {
		... ChartFragment
	}
	terraform {
		... TerraformFragment
	}
	configuration {
		... RecipeConfigurationFragment
	}
}
fragment DependenciesFragment on Dependencies {
	dependencies {
		type
		name
		repo
	}
	wait
	application
	providers
	secrets
	wirings {
		terraform
		helm
	}
	providerWirings
	outputs
	providerVsn
}
fragment RecipeConfigurationFragment on RecipeConfiguration {
	name
	type
	default
	documentation
	optional
	placeholder
	functionName
	condition {
		field
		operation
		value
	}
	validation {
		type
		regex
		message
	}
}
`

func (c *Client) GetStack(ctx context.Context, name string, provider Provider, httpRequestOptions ...client.HTTPRequestOption) (*GetStack, error) {
	vars := map[string]interface{}{
		"name":     name,
		"provider": provider,
	}

	var res GetStack
	if err := c.Client.Post(ctx, "GetStack", GetStackDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const ListStacksDocument = `query ListStacks ($featured: Boolean, $cursor: String) {
	stacks(first: 100, after: $cursor, featured: $featured) {
		edges {
			node {
				... StackFragment
			}
		}
	}
}
fragment RecipeSectionFragment on RecipeSection {
	index
	repository {
		... RepositoryFragment
	}
	recipeItems {
		... RecipeItemFragment
	}
	configuration {
		... RecipeConfigurationFragment
	}
}
fragment RecipeItemFragment on RecipeItem {
	id
	chart {
		... ChartFragment
	}
	terraform {
		... TerraformFragment
	}
	configuration {
		... RecipeConfigurationFragment
	}
}
fragment TerraformFragment on Terraform {
	id
	name
	package
	description
	dependencies {
		... DependenciesFragment
	}
	valuesTemplate
}
fragment RecipeConfigurationFragment on RecipeConfiguration {
	name
	type
	default
	documentation
	optional
	placeholder
	functionName
	condition {
		field
		operation
		value
	}
	validation {
		type
		regex
		message
	}
}
fragment StackFragment on Stack {
	id
	name
	featured
	description
	bundles {
		... RecipeFragment
	}
}
fragment RecipeFragment on Recipe {
	id
	name
	description
	restricted
	provider
	tests {
		type
		name
		message
		args {
			name
			repo
			key
		}
	}
	repository {
		id
		name
	}
	oidcSettings {
		uriFormat
		uriFormats
		authMethod
		domainKey
		subdomain
	}
	recipeSections {
		... RecipeSectionFragment
	}
}
fragment RepositoryFragment on Repository {
	id
	name
	notes
	icon
	darkIcon
	description
	publisher {
		name
	}
	recipes {
		name
	}
}
fragment ChartFragment on Chart {
	id
	name
	description
	latestVersion
}
fragment DependenciesFragment on Dependencies {
	dependencies {
		type
		name
		repo
	}
	wait
	application
	providers
	secrets
	wirings {
		terraform
		helm
	}
	providerWirings
	outputs
	providerVsn
}
`

func (c *Client) ListStacks(ctx context.Context, featured *bool, cursor *string, httpRequestOptions ...client.HTTPRequestOption) (*ListStacks, error) {
	vars := map[string]interface{}{
		"featured": featured,
		"cursor":   cursor,
	}

	var res ListStacks
	if err := c.Client.Post(ctx, "ListStacks", ListStacksDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const GetRepositoryDocument = `query GetRepository ($name: String) {
	repository(name: $name) {
		... RepositoryFragment
	}
}
fragment RepositoryFragment on Repository {
	id
	name
	notes
	icon
	darkIcon
	description
	publisher {
		name
	}
	recipes {
		name
	}
}
`

func (c *Client) GetRepository(ctx context.Context, name *string, httpRequestOptions ...client.HTTPRequestOption) (*GetRepository, error) {
	vars := map[string]interface{}{
		"name": name,
	}

	var res GetRepository
	if err := c.Client.Post(ctx, "GetRepository", GetRepositoryDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const CreateResourceDefinitionDocument = `mutation CreateResourceDefinition ($name: String!, $input: ResourceDefinitionAttributes!) {
	updateRepository(repositoryName: $name, attributes: {integrationResourceDefinition:$input}) {
		id
	}
}
`

func (c *Client) CreateResourceDefinition(ctx context.Context, name string, input ResourceDefinitionAttributes, httpRequestOptions ...client.HTTPRequestOption) (*CreateResourceDefinition, error) {
	vars := map[string]interface{}{
		"name":  name,
		"input": input,
	}

	var res CreateResourceDefinition
	if err := c.Client.Post(ctx, "CreateResourceDefinition", CreateResourceDefinitionDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const CreateIntegrationDocument = `mutation CreateIntegration ($name: String!, $attrs: IntegrationAttributes!) {
	createIntegration(repositoryName: $name, attributes: $attrs) {
		id
	}
}
`

func (c *Client) CreateIntegration(ctx context.Context, name string, attrs IntegrationAttributes, httpRequestOptions ...client.HTTPRequestOption) (*CreateIntegration, error) {
	vars := map[string]interface{}{
		"name":  name,
		"attrs": attrs,
	}

	var res CreateIntegration
	if err := c.Client.Post(ctx, "CreateIntegration", CreateIntegrationDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const UpdateRepositoryDocument = `mutation UpdateRepository ($name: String!, $attrs: RepositoryAttributes!) {
	updateRepository(repositoryName: $name, attributes: $attrs) {
		id
	}
}
`

func (c *Client) UpdateRepository(ctx context.Context, name string, attrs RepositoryAttributes, httpRequestOptions ...client.HTTPRequestOption) (*UpdateRepository, error) {
	vars := map[string]interface{}{
		"name":  name,
		"attrs": attrs,
	}

	var res UpdateRepository
	if err := c.Client.Post(ctx, "UpdateRepository", UpdateRepositoryDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const CreateRepositoryDocument = `mutation CreateRepository ($name: String!, $publisher: String!, $attributes: RepositoryAttributes!) {
	upsertRepository(name: $name, publisher: $publisher, attributes: $attributes) {
		id
	}
}
`

func (c *Client) CreateRepository(ctx context.Context, name string, publisher string, attributes RepositoryAttributes, httpRequestOptions ...client.HTTPRequestOption) (*CreateRepository, error) {
	vars := map[string]interface{}{
		"name":       name,
		"publisher":  publisher,
		"attributes": attributes,
	}

	var res CreateRepository
	if err := c.Client.Post(ctx, "CreateRepository", CreateRepositoryDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const AcquireLockDocument = `mutation AcquireLock ($name: String!) {
	acquireLock(repository: $name) {
		... ApplyLockFragment
	}
}
fragment ApplyLockFragment on ApplyLock {
	id
	lock
}
`

func (c *Client) AcquireLock(ctx context.Context, name string, httpRequestOptions ...client.HTTPRequestOption) (*AcquireLock, error) {
	vars := map[string]interface{}{
		"name": name,
	}

	var res AcquireLock
	if err := c.Client.Post(ctx, "AcquireLock", AcquireLockDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const ReleaseLockDocument = `mutation ReleaseLock ($name: String!, $attrs: LockAttributes!) {
	releaseLock(repository: $name, attributes: $attrs) {
		... ApplyLockFragment
	}
}
fragment ApplyLockFragment on ApplyLock {
	id
	lock
}
`

func (c *Client) ReleaseLock(ctx context.Context, name string, attrs LockAttributes, httpRequestOptions ...client.HTTPRequestOption) (*ReleaseLock, error) {
	vars := map[string]interface{}{
		"name":  name,
		"attrs": attrs,
	}

	var res ReleaseLock
	if err := c.Client.Post(ctx, "ReleaseLock", ReleaseLockDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const UnlockRepositoryDocument = `mutation UnlockRepository ($name: String!) {
	unlockRepository(name: $name)
}
`

func (c *Client) UnlockRepository(ctx context.Context, name string, httpRequestOptions ...client.HTTPRequestOption) (*UnlockRepository, error) {
	vars := map[string]interface{}{
		"name": name,
	}

	var res UnlockRepository
	if err := c.Client.Post(ctx, "UnlockRepository", UnlockRepositoryDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const ListRepositoriesDocument = `query ListRepositories ($q: String) {
	repositories(q: $q, first: 100) {
		edges {
			node {
				... RepositoryFragment
			}
		}
	}
}
fragment RepositoryFragment on Repository {
	id
	name
	notes
	icon
	darkIcon
	description
	publisher {
		name
	}
	recipes {
		name
	}
}
`

func (c *Client) ListRepositories(ctx context.Context, q *string, httpRequestOptions ...client.HTTPRequestOption) (*ListRepositories, error) {
	vars := map[string]interface{}{
		"q": q,
	}

	var res ListRepositories
	if err := c.Client.Post(ctx, "ListRepositories", ListRepositoriesDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const ScaffoldsDocument = `query Scaffolds ($app: String!, $pub: String!, $cat: Category!, $ing: Boolean, $pg: Boolean) {
	scaffold(application: $app, publisher: $pub, category: $cat, ingress: $ing, postgres: $pg) {
		path
		content
	}
}
`

func (c *Client) Scaffolds(ctx context.Context, app string, pub string, cat Category, ing *bool, pg *bool, httpRequestOptions ...client.HTTPRequestOption) (*Scaffolds, error) {
	vars := map[string]interface{}{
		"app": app,
		"pub": pub,
		"cat": cat,
		"ing": ing,
		"pg":  pg,
	}

	var res Scaffolds
	if err := c.Client.Post(ctx, "Scaffolds", ScaffoldsDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const DeleteRepositoryDocument = `mutation DeleteRepository ($id: ID!) {
	deleteRepository(repositoryId: $id) {
		id
	}
}
`

func (c *Client) DeleteRepository(ctx context.Context, id string, httpRequestOptions ...client.HTTPRequestOption) (*DeleteRepository, error) {
	vars := map[string]interface{}{
		"id": id,
	}

	var res DeleteRepository
	if err := c.Client.Post(ctx, "DeleteRepository", DeleteRepositoryDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const GetTfProvidersDocument = `query GetTfProviders {
	terraformProviders
}
`

func (c *Client) GetTfProviders(ctx context.Context, httpRequestOptions ...client.HTTPRequestOption) (*GetTfProviders, error) {
	vars := map[string]interface{}{}

	var res GetTfProviders
	if err := c.Client.Post(ctx, "GetTfProviders", GetTfProvidersDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const GetTfProviderScaffoldDocument = `query GetTfProviderScaffold ($name: Provider!, $vsn: String) {
	terraformProvider(name: $name, vsn: $vsn) {
		name
		content
	}
}
`

func (c *Client) GetTfProviderScaffold(ctx context.Context, name Provider, vsn *string, httpRequestOptions ...client.HTTPRequestOption) (*GetTfProviderScaffold, error) {
	vars := map[string]interface{}{
		"name": name,
		"vsn":  vsn,
	}

	var res GetTfProviderScaffold
	if err := c.Client.Post(ctx, "GetTfProviderScaffold", GetTfProviderScaffoldDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const GetShellDocument = `query GetShell {
	shell {
		... CloudShellFragment
	}
}
fragment CloudShellFragment on CloudShell {
	id
	aesKey
	gitUrl
}
`

func (c *Client) GetShell(ctx context.Context, httpRequestOptions ...client.HTTPRequestOption) (*GetShell, error) {
	vars := map[string]interface{}{}

	var res GetShell
	if err := c.Client.Post(ctx, "GetShell", GetShellDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const DeleteShellDocument = `mutation DeleteShell {
	deleteShell {
		... CloudShellFragment
	}
}
fragment CloudShellFragment on CloudShell {
	id
	aesKey
	gitUrl
}
`

func (c *Client) DeleteShell(ctx context.Context, httpRequestOptions ...client.HTTPRequestOption) (*DeleteShell, error) {
	vars := map[string]interface{}{}

	var res DeleteShell
	if err := c.Client.Post(ctx, "DeleteShell", DeleteShellDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const GetTerraformDocument = `query GetTerraform ($id: ID!) {
	terraform(repositoryId: $id, first: 100) {
		edges {
			node {
				... TerraformFragment
			}
		}
	}
}
fragment TerraformFragment on Terraform {
	id
	name
	package
	description
	dependencies {
		... DependenciesFragment
	}
	valuesTemplate
}
fragment DependenciesFragment on Dependencies {
	dependencies {
		type
		name
		repo
	}
	wait
	application
	providers
	secrets
	wirings {
		terraform
		helm
	}
	providerWirings
	outputs
	providerVsn
}
`

func (c *Client) GetTerraform(ctx context.Context, id string, httpRequestOptions ...client.HTTPRequestOption) (*GetTerraform, error) {
	vars := map[string]interface{}{
		"id": id,
	}

	var res GetTerraform
	if err := c.Client.Post(ctx, "GetTerraform", GetTerraformDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const GetTerraformInstallationsDocument = `query GetTerraformInstallations ($id: ID!) {
	terraformInstallations(repositoryId: $id, first: 100) {
		edges {
			node {
				... TerraformInstallationFragment
			}
		}
	}
}
fragment TerraformInstallationFragment on TerraformInstallation {
	id
	terraform {
		... TerraformFragment
	}
	version {
		... VersionFragment
	}
}
fragment TerraformFragment on Terraform {
	id
	name
	package
	description
	dependencies {
		... DependenciesFragment
	}
	valuesTemplate
}
fragment DependenciesFragment on Dependencies {
	dependencies {
		type
		name
		repo
	}
	wait
	application
	providers
	secrets
	wirings {
		terraform
		helm
	}
	providerWirings
	outputs
	providerVsn
}
fragment VersionFragment on Version {
	id
	readme
	version
	valuesTemplate
	package
	crds {
		... CrdFragment
	}
	dependencies {
		... DependenciesFragment
	}
}
fragment CrdFragment on Crd {
	id
	name
	blob
}
`

func (c *Client) GetTerraformInstallations(ctx context.Context, id string, httpRequestOptions ...client.HTTPRequestOption) (*GetTerraformInstallations, error) {
	vars := map[string]interface{}{
		"id": id,
	}

	var res GetTerraformInstallations
	if err := c.Client.Post(ctx, "GetTerraformInstallations", GetTerraformInstallationsDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const UploadTerraformDocument = `mutation UploadTerraform ($repoName: String!, $name: String!, $uploadOrUrl: UploadOrUrl!) {
	uploadTerraform(repositoryName: $repoName, name: $name, attributes: {name:$name,package:$uploadOrUrl}) {
		... TerraformFragment
	}
}
fragment TerraformFragment on Terraform {
	id
	name
	package
	description
	dependencies {
		... DependenciesFragment
	}
	valuesTemplate
}
fragment DependenciesFragment on Dependencies {
	dependencies {
		type
		name
		repo
	}
	wait
	application
	providers
	secrets
	wirings {
		terraform
		helm
	}
	providerWirings
	outputs
	providerVsn
}
`

func (c *Client) UploadTerraform(ctx context.Context, repoName string, name string, uploadOrURL string, httpRequestOptions ...client.HTTPRequestOption) (*UploadTerraform, error) {
	vars := map[string]interface{}{
		"repoName":    repoName,
		"name":        name,
		"uploadOrUrl": uploadOrURL,
	}

	var res UploadTerraform
	if err := c.Client.Post(ctx, "UploadTerraform", UploadTerraformDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const UninstallTerraformDocument = `mutation UninstallTerraform ($id: ID!) {
	uninstallTerraform(id: $id) {
		id
	}
}
`

func (c *Client) UninstallTerraform(ctx context.Context, id string, httpRequestOptions ...client.HTTPRequestOption) (*UninstallTerraform, error) {
	vars := map[string]interface{}{
		"id": id,
	}

	var res UninstallTerraform
	if err := c.Client.Post(ctx, "UninstallTerraform", UninstallTerraformDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const CreateTestDocument = `mutation CreateTest ($name: String!, $attrs: TestAttributes!) {
	createTest(name: $name, attributes: $attrs) {
		... TestFragment
	}
}
fragment TestFragment on Test {
	id
	name
	status
	promoteTag
	steps {
		id
		name
		description
		status
	}
}
`

func (c *Client) CreateTest(ctx context.Context, name string, attrs TestAttributes, httpRequestOptions ...client.HTTPRequestOption) (*CreateTest, error) {
	vars := map[string]interface{}{
		"name":  name,
		"attrs": attrs,
	}

	var res CreateTest
	if err := c.Client.Post(ctx, "CreateTest", CreateTestDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const UpdateTestDocument = `mutation UpdateTest ($id: ID!, $attrs: TestAttributes!) {
	updateTest(id: $id, attributes: $attrs) {
		... TestFragment
	}
}
fragment TestFragment on Test {
	id
	name
	status
	promoteTag
	steps {
		id
		name
		description
		status
	}
}
`

func (c *Client) UpdateTest(ctx context.Context, id string, attrs TestAttributes, httpRequestOptions ...client.HTTPRequestOption) (*UpdateTest, error) {
	vars := map[string]interface{}{
		"id":    id,
		"attrs": attrs,
	}

	var res UpdateTest
	if err := c.Client.Post(ctx, "UpdateTest", UpdateTestDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const UpdateStepDocument = `mutation UpdateStep ($id: ID!, $logs: UploadOrUrl!) {
	updateStep(id: $id, attributes: {logs:$logs}) {
		id
	}
}
`

func (c *Client) UpdateStep(ctx context.Context, id string, logs string, httpRequestOptions ...client.HTTPRequestOption) (*UpdateStep, error) {
	vars := map[string]interface{}{
		"id":   id,
		"logs": logs,
	}

	var res UpdateStep
	if err := c.Client.Post(ctx, "UpdateStep", UpdateStepDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const PublishLogsDocument = `mutation PublishLogs ($id: ID!, $logs: String!) {
	publishLogs(id: $id, logs: $logs) {
		id
	}
}
`

func (c *Client) PublishLogs(ctx context.Context, id string, logs string, httpRequestOptions ...client.HTTPRequestOption) (*PublishLogs, error) {
	vars := map[string]interface{}{
		"id":   id,
		"logs": logs,
	}

	var res PublishLogs
	if err := c.Client.Post(ctx, "PublishLogs", PublishLogsDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const MeDocument = `query Me {
	me {
		id
		email
	}
}
`

func (c *Client) Me(ctx context.Context, httpRequestOptions ...client.HTTPRequestOption) (*Me, error) {
	vars := map[string]interface{}{}

	var res Me
	if err := c.Client.Post(ctx, "Me", MeDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const GetLoginMethodDocument = `query GetLoginMethod ($email: String!) {
	loginMethod(email: $email) {
		loginMethod
		token
	}
}
`

func (c *Client) GetLoginMethod(ctx context.Context, email string, httpRequestOptions ...client.HTTPRequestOption) (*GetLoginMethod, error) {
	vars := map[string]interface{}{
		"email": email,
	}

	var res GetLoginMethod
	if err := c.Client.Post(ctx, "GetLoginMethod", GetLoginMethodDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const ListTokensDocument = `query ListTokens {
	tokens(first: 3) {
		edges {
			node {
				token
			}
		}
	}
}
`

func (c *Client) ListTokens(ctx context.Context, httpRequestOptions ...client.HTTPRequestOption) (*ListTokens, error) {
	vars := map[string]interface{}{}

	var res ListTokens
	if err := c.Client.Post(ctx, "ListTokens", ListTokensDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const ListKeysDocument = `query ListKeys ($emails: [String]) {
	publicKeys(emails: $emails, first: 1000) {
		edges {
			node {
				... PublicKeyFragment
			}
		}
	}
}
fragment PublicKeyFragment on PublicKey {
	id
	content
	user {
		... UserFragment
	}
}
fragment UserFragment on User {
	id
	name
	email
}
`

func (c *Client) ListKeys(ctx context.Context, emails []*string, httpRequestOptions ...client.HTTPRequestOption) (*ListKeys, error) {
	vars := map[string]interface{}{
		"emails": emails,
	}

	var res ListKeys
	if err := c.Client.Post(ctx, "ListKeys", ListKeysDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const GetEabCredentialDocument = `query GetEabCredential ($cluster: String!, $provider: Provider!) {
	eabCredential(cluster: $cluster, provider: $provider) {
		... EabCredentialFragment
	}
}
fragment EabCredentialFragment on EabCredential {
	id
	keyId
	hmacKey
	cluster
	provider
}
`

func (c *Client) GetEabCredential(ctx context.Context, cluster string, provider Provider, httpRequestOptions ...client.HTTPRequestOption) (*GetEabCredential, error) {
	vars := map[string]interface{}{
		"cluster":  cluster,
		"provider": provider,
	}

	var res GetEabCredential
	if err := c.Client.Post(ctx, "GetEabCredential", GetEabCredentialDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const PollLoginTokenDocument = `mutation PollLoginToken ($token: String!) {
	loginToken(token: $token) {
		jwt
	}
}
`

func (c *Client) PollLoginToken(ctx context.Context, token string, httpRequestOptions ...client.HTTPRequestOption) (*PollLoginToken, error) {
	vars := map[string]interface{}{
		"token": token,
	}

	var res PollLoginToken
	if err := c.Client.Post(ctx, "PollLoginToken", PollLoginTokenDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const DevLoginDocument = `mutation DevLogin {
	deviceLogin {
		loginUrl
		deviceToken
	}
}
`

func (c *Client) DevLogin(ctx context.Context, httpRequestOptions ...client.HTTPRequestOption) (*DevLogin, error) {
	vars := map[string]interface{}{}

	var res DevLogin
	if err := c.Client.Post(ctx, "DevLogin", DevLoginDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const LoginDocument = `mutation Login ($email: String!, $pwd: String!) {
	login(email: $email, password: $pwd) {
		jwt
	}
}
`

func (c *Client) Login(ctx context.Context, email string, pwd string, httpRequestOptions ...client.HTTPRequestOption) (*Login, error) {
	vars := map[string]interface{}{
		"email": email,
		"pwd":   pwd,
	}

	var res Login
	if err := c.Client.Post(ctx, "Login", LoginDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const ImpersonateServiceAccountDocument = `mutation ImpersonateServiceAccount ($email: String) {
	impersonateServiceAccount(email: $email) {
		jwt
		email
	}
}
`

func (c *Client) ImpersonateServiceAccount(ctx context.Context, email *string, httpRequestOptions ...client.HTTPRequestOption) (*ImpersonateServiceAccount, error) {
	vars := map[string]interface{}{
		"email": email,
	}

	var res ImpersonateServiceAccount
	if err := c.Client.Post(ctx, "ImpersonateServiceAccount", ImpersonateServiceAccountDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const CreateAccessTokenDocument = `mutation CreateAccessToken {
	createToken {
		token
	}
}
`

func (c *Client) CreateAccessToken(ctx context.Context, httpRequestOptions ...client.HTTPRequestOption) (*CreateAccessToken, error) {
	vars := map[string]interface{}{}

	var res CreateAccessToken
	if err := c.Client.Post(ctx, "CreateAccessToken", CreateAccessTokenDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const CreateKeyDocument = `mutation CreateKey ($key: String!, $name: String!) {
	createPublicKey(attributes: {content:$key,name:$name}) {
		id
	}
}
`

func (c *Client) CreateKey(ctx context.Context, key string, name string, httpRequestOptions ...client.HTTPRequestOption) (*CreateKey, error) {
	vars := map[string]interface{}{
		"key":  key,
		"name": name,
	}

	var res CreateKey
	if err := c.Client.Post(ctx, "CreateKey", CreateKeyDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const DeleteEabCredentialDocument = `mutation DeleteEabCredential ($cluster: String!, $provider: Provider!) {
	deleteEabKey(cluster: $cluster, provider: $provider) {
		id
	}
}
`

func (c *Client) DeleteEabCredential(ctx context.Context, cluster string, provider Provider, httpRequestOptions ...client.HTTPRequestOption) (*DeleteEabCredential, error) {
	vars := map[string]interface{}{
		"cluster":  cluster,
		"provider": provider,
	}

	var res DeleteEabCredential
	if err := c.Client.Post(ctx, "DeleteEabCredential", DeleteEabCredentialDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const CreateEventDocument = `mutation CreateEvent ($attrs: UserEventAttributes!) {
	createUserEvent(attributes: $attrs)
}
`

func (c *Client) CreateEvent(ctx context.Context, attrs UserEventAttributes, httpRequestOptions ...client.HTTPRequestOption) (*CreateEvent, error) {
	vars := map[string]interface{}{
		"attrs": attrs,
	}

	var res CreateEvent
	if err := c.Client.Post(ctx, "CreateEvent", CreateEventDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const CreateBackupDocument = `mutation CreateBackup ($attrs: KeyBackupAttributes!) {
	createKeyBackup(attributes: $attrs) {
		... KeyBackupFragment
	}
}
fragment KeyBackupFragment on KeyBackup {
	id
	name
	repositories
}
`

func (c *Client) CreateBackup(ctx context.Context, attrs KeyBackupAttributes, httpRequestOptions ...client.HTTPRequestOption) (*CreateBackup, error) {
	vars := map[string]interface{}{
		"attrs": attrs,
	}

	var res CreateBackup
	if err := c.Client.Post(ctx, "CreateBackup", CreateBackupDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const BackupsDocument = `query Backups ($cursor: String) {
	keyBackups(first: 50, after: $cursor) {
		edges {
			node {
				... KeyBackupFragment
			}
		}
	}
}
fragment KeyBackupFragment on KeyBackup {
	id
	name
	repositories
}
`

func (c *Client) Backups(ctx context.Context, cursor *string, httpRequestOptions ...client.HTTPRequestOption) (*Backups, error) {
	vars := map[string]interface{}{
		"cursor": cursor,
	}

	var res Backups
	if err := c.Client.Post(ctx, "Backups", BackupsDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const BackupDocument = `query Backup ($name: String!) {
	keyBackup(name: $name) {
		... KeyBackupFragment
		value
	}
}
fragment KeyBackupFragment on KeyBackup {
	id
	name
	repositories
}
`

func (c *Client) Backup(ctx context.Context, name string, httpRequestOptions ...client.HTTPRequestOption) (*Backup, error) {
	vars := map[string]interface{}{
		"name": name,
	}

	var res Backup
	if err := c.Client.Post(ctx, "Backup", BackupDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const GetHelpDocument = `query GetHelp ($prompt: String!) {
	helpQuestion(prompt: $prompt)
}
`

func (c *Client) GetHelp(ctx context.Context, prompt string, httpRequestOptions ...client.HTTPRequestOption) (*GetHelp, error) {
	vars := map[string]interface{}{
		"prompt": prompt,
	}

	var res GetHelp
	if err := c.Client.Post(ctx, "GetHelp", GetHelpDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}

const UpdateVersionDocument = `mutation UpdateVersion ($spec: VersionSpec, $attributes: VersionAttributes!) {
	updateVersion(spec: $spec, attributes: $attributes) {
		id
	}
}
`

func (c *Client) UpdateVersion(ctx context.Context, spec *VersionSpec, attributes VersionAttributes, httpRequestOptions ...client.HTTPRequestOption) (*UpdateVersion, error) {
	vars := map[string]interface{}{
		"spec":       spec,
		"attributes": attributes,
	}

	var res UpdateVersion
	if err := c.Client.Post(ctx, "UpdateVersion", UpdateVersionDocument, &res, vars, httpRequestOptions...); err != nil {
		return nil, err
	}

	return &res, nil
}
