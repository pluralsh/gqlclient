// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package gqlclient

import (
	"fmt"
	"io"
	"strconv"
)

type Account struct {
	BackgroundColor    *string          `json:"backgroundColor"`
	BillingCustomerID  *string          `json:"billingCustomerId"`
	DomainMappings     []*DomainMapping `json:"domainMappings"`
	Icon               *string          `json:"icon"`
	ID                 string           `json:"id"`
	InsertedAt         *string          `json:"insertedAt"`
	Name               *string          `json:"name"`
	RootUser           *User            `json:"rootUser"`
	UpdatedAt          *string          `json:"updatedAt"`
	WorkosConnectionID *string          `json:"workosConnectionId"`
}

type AccountAttributes struct {
	DomainMappings []*DomainMappingInput `json:"domainMappings,omitempty"`
	Icon           *string               `json:"icon,omitempty"`
	Name           *string               `json:"name,omitempty"`
}

type ActionItem struct {
	Link string         `json:"link"`
	Type ActionItemType `json:"type"`
}

type ActionItemAttributes struct {
	Link string         `json:"link"`
	Type ActionItemType `json:"type"`
}

type Address struct {
	City    *string `json:"city"`
	Country *string `json:"country"`
	Line1   *string `json:"line1"`
	Line2   *string `json:"line2"`
	State   *string `json:"state"`
	Zip     *string `json:"zip"`
}

type AddressAttributes struct {
	City    string `json:"city"`
	Country string `json:"country"`
	Line1   string `json:"line1"`
	Line2   string `json:"line2"`
	State   string `json:"state"`
	Zip     string `json:"zip"`
}

type ApplyLock struct {
	ID         string      `json:"id"`
	InsertedAt *string     `json:"insertedAt"`
	Lock       *string     `json:"lock"`
	Owner      *User       `json:"owner"`
	Repository *Repository `json:"repository"`
	UpdatedAt  *string     `json:"updatedAt"`
}

type Artifact struct {
	Arch       *string           `json:"arch"`
	Blob       *string           `json:"blob"`
	Filesize   *int64            `json:"filesize"`
	ID         *string           `json:"id"`
	InsertedAt *string           `json:"insertedAt"`
	Name       *string           `json:"name"`
	Platform   *ArtifactPlatform `json:"platform"`
	Readme     *string           `json:"readme"`
	Sha        *string           `json:"sha"`
	Type       *ArtifactType     `json:"type"`
	UpdatedAt  *string           `json:"updatedAt"`
}

type ArtifactAttributes struct {
	Arch     *string `json:"arch,omitempty"`
	Blob     *string `json:"blob,omitempty"`
	Name     string  `json:"name"`
	Platform string  `json:"platform"`
	Readme   string  `json:"readme"`
	Type     string  `json:"type"`
}

type Audit struct {
	Action             string              `json:"action"`
	Actor              *User               `json:"actor"`
	City               *string             `json:"city"`
	Country            *string             `json:"country"`
	Group              *Group              `json:"group"`
	ID                 string              `json:"id"`
	Image              *DockerImage        `json:"image"`
	InsertedAt         *string             `json:"insertedAt"`
	IntegrationWebhook *IntegrationWebhook `json:"integrationWebhook"`
	IP                 *string             `json:"ip"`
	Latitude           *string             `json:"latitude"`
	Longitude          *string             `json:"longitude"`
	Repository         *Repository         `json:"repository"`
	Role               *Role               `json:"role"`
	UpdatedAt          *string             `json:"updatedAt"`
	User               *User               `json:"user"`
	Version            *Version            `json:"version"`
}

type AuditConnection struct {
	Edges    []*AuditEdge `json:"edges"`
	PageInfo PageInfo     `json:"pageInfo"`
}

type AuditEdge struct {
	Cursor *string `json:"cursor"`
	Node   *Audit  `json:"node"`
}

type AuthorizationURL struct {
	Provider ScmProvider `json:"provider"`
	URL      string      `json:"url"`
}

type AwsShellCredentialsAttributes struct {
	AccessKeyID     string `json:"accessKeyId"`
	SecretAccessKey string `json:"secretAccessKey"`
}

type AzureShellCredentialsAttributes struct {
	ClientID       string `json:"clientId"`
	ClientSecret   string `json:"clientSecret"`
	StorageAccount string `json:"storageAccount"`
	SubscriptionID string `json:"subscriptionId"`
	TenantID       string `json:"tenantId"`
}

type BindingAttributes struct {
	GroupID *string `json:"groupId,omitempty"`
	ID      *string `json:"id,omitempty"`
	UserID  *string `json:"userId,omitempty"`
}

type Card struct {
	Brand    string  `json:"brand"`
	ExpMonth int64   `json:"expMonth"`
	ExpYear  int64   `json:"expYear"`
	ID       string  `json:"id"`
	Last4    string  `json:"last4"`
	Name     *string `json:"name"`
}

type CardConnection struct {
	Edges    []*CardEdge `json:"edges"`
	PageInfo PageInfo    `json:"pageInfo"`
}

type CardEdge struct {
	Cursor *string `json:"cursor"`
	Node   *Card   `json:"node"`
}

type CategoryInfo struct {
	Category *Category             `json:"category"`
	Count    *int64                `json:"count"`
	Tags     *GroupedTagConnection `json:"tags"`
}

type ChangeInstructions struct {
	Instructions *string `json:"instructions"`
	Script       *string `json:"script"`
}

type Chart struct {
	Dependencies  *Dependencies      `json:"dependencies"`
	Description   *string            `json:"description"`
	ID            *string            `json:"id"`
	InsertedAt    *string            `json:"insertedAt"`
	Installation  *ChartInstallation `json:"installation"`
	LatestVersion *string            `json:"latestVersion"`
	Name          string             `json:"name"`
	Repository    *Repository        `json:"repository"`
	Tags          []*VersionTag      `json:"tags"`
	UpdatedAt     *string            `json:"updatedAt"`
}

type ChartAttributes struct {
	Tags []*VersionTagAttributes `json:"tags,omitempty"`
}

type ChartConnection struct {
	Edges    []*ChartEdge `json:"edges"`
	PageInfo PageInfo     `json:"pageInfo"`
}

type ChartEdge struct {
	Cursor *string `json:"cursor"`
	Node   *Chart  `json:"node"`
}

type ChartInstallation struct {
	Chart        *Chart        `json:"chart"`
	ID           *string       `json:"id"`
	InsertedAt   *string       `json:"insertedAt"`
	Installation *Installation `json:"installation"`
	UpdatedAt    *string       `json:"updatedAt"`
	Version      *Version      `json:"version"`
}

type ChartInstallationAttributes struct {
	ChartID   *string `json:"chartId,omitempty"`
	VersionID *string `json:"versionId,omitempty"`
}

type ChartInstallationConnection struct {
	Edges    []*ChartInstallationEdge `json:"edges"`
	PageInfo PageInfo                 `json:"pageInfo"`
}

type ChartInstallationEdge struct {
	Cursor *string            `json:"cursor"`
	Node   *ChartInstallation `json:"node"`
}

type ChartName struct {
	Chart *string `json:"chart,omitempty"`
	Repo  *string `json:"repo,omitempty"`
}

type ClosureItem struct {
	Dep       *Dependency `json:"dep"`
	Helm      *Chart      `json:"helm"`
	Terraform *Terraform  `json:"terraform"`
}

type CloudShell struct {
	AesKey     string       `json:"aesKey"`
	Alive      bool         `json:"alive"`
	Cluster    string       `json:"cluster"`
	GitURL     string       `json:"gitUrl"`
	ID         string       `json:"id"`
	InsertedAt *string      `json:"insertedAt"`
	Provider   Provider     `json:"provider"`
	Status     *ShellStatus `json:"status"`
	Subdomain  string       `json:"subdomain"`
	UpdatedAt  *string      `json:"updatedAt"`
}

type CloudShellAttributes struct {
	Credentials ShellCredentialsAttributes `json:"credentials"`
	DemoID      *string                    `json:"demoId,omitempty"`
	Provider    *Provider                  `json:"provider,omitempty"`
	Scm         *ScmAttributes             `json:"scm,omitempty"`
	Workspace   WorkspaceAttributes        `json:"workspace"`
}

type ClusterInformation struct {
	GitCommit  *string `json:"gitCommit"`
	ID         string  `json:"id"`
	InsertedAt *string `json:"insertedAt"`
	Platform   *string `json:"platform"`
	UpdatedAt  *string `json:"updatedAt"`
	Version    *string `json:"version"`
}

type ClusterInformationAttributes struct {
	GitCommit *string `json:"gitCommit,omitempty"`
	Platform  *string `json:"platform,omitempty"`
	Version   *string `json:"version,omitempty"`
}

type Community struct {
	Discord  *string   `json:"discord"`
	GitURL   *string   `json:"gitUrl"`
	Homepage *string   `json:"homepage"`
	Slack    *string   `json:"slack"`
	Twitter  *string   `json:"twitter"`
	Videos   []*string `json:"videos"`
}

type CommunityAttributes struct {
	Discord  *string   `json:"discord,omitempty"`
	GitURL   *string   `json:"gitUrl,omitempty"`
	Homepage *string   `json:"homepage,omitempty"`
	Slack    *string   `json:"slack,omitempty"`
	Twitter  *string   `json:"twitter,omitempty"`
	Videos   []*string `json:"videos,omitempty"`
}

type ConsentRequest struct {
	RequestedScope []*string `json:"requestedScope"`
	Skip           *bool     `json:"skip"`
}

type Crd struct {
	Blob       *string `json:"blob"`
	ID         string  `json:"id"`
	InsertedAt *string `json:"insertedAt"`
	Name       string  `json:"name"`
	UpdatedAt  *string `json:"updatedAt"`
}

type CrdAttributes struct {
	Blob *string `json:"blob,omitempty"`
	Name string  `json:"name"`
}

type Cvss struct {
	AttackComplexity   *VulnGrade       `json:"attackComplexity"`
	AttackVector       *VulnVector      `json:"attackVector"`
	Availability       *VulnGrade       `json:"availability"`
	Confidentiality    *VulnGrade       `json:"confidentiality"`
	Integrity          *VulnGrade       `json:"integrity"`
	PrivilegesRequired *VulnGrade       `json:"privilegesRequired"`
	UserInteraction    *VulnRequirement `json:"userInteraction"`
}

type DeferredUpdate struct {
	Attempts              *int64                 `json:"attempts"`
	ChartInstallation     *ChartInstallation     `json:"chartInstallation"`
	DequeueAt             *string                `json:"dequeueAt"`
	ID                    string                 `json:"id"`
	InsertedAt            *string                `json:"insertedAt"`
	TerraformInstallation *TerraformInstallation `json:"terraformInstallation"`
	UpdatedAt             *string                `json:"updatedAt"`
	Version               *Version               `json:"version"`
}

type DeferredUpdateConnection struct {
	Edges    []*DeferredUpdateEdge `json:"edges"`
	PageInfo PageInfo              `json:"pageInfo"`
}

type DeferredUpdateEdge struct {
	Cursor *string         `json:"cursor"`
	Node   *DeferredUpdate `json:"node"`
}

type DemoProject struct {
	Credentials *string           `json:"credentials"`
	ID          string            `json:"id"`
	InsertedAt  *string           `json:"insertedAt"`
	ProjectID   string            `json:"projectId"`
	Ready       *bool             `json:"ready"`
	State       *DemoProjectState `json:"state"`
	UpdatedAt   *string           `json:"updatedAt"`
}

type Dependencies struct {
	Application     *bool                  `json:"application"`
	Breaking        *bool                  `json:"breaking"`
	Dependencies    []*Dependency          `json:"dependencies"`
	Instructions    *ChangeInstructions    `json:"instructions"`
	Outputs         map[string]interface{} `json:"outputs"`
	ProviderVsn     *string                `json:"providerVsn"`
	ProviderWirings map[string]interface{} `json:"providerWirings"`
	Providers       []*Provider            `json:"providers"`
	Secrets         []*string              `json:"secrets"`
	Wait            *bool                  `json:"wait"`
	Wirings         *Wirings               `json:"wirings"`
}

type Dependency struct {
	Name     *string         `json:"name"`
	Optional *bool           `json:"optional"`
	Repo     *string         `json:"repo"`
	Type     *DependencyType `json:"type"`
	Version  *string         `json:"version"`
}

type DeviceLogin struct {
	DeviceToken string `json:"deviceToken"`
	LoginURL    string `json:"loginUrl"`
}

type DNSAccessPolicy struct {
	Bindings   []*PolicyBinding `json:"bindings"`
	ID         string           `json:"id"`
	InsertedAt *string          `json:"insertedAt"`
	UpdatedAt  *string          `json:"updatedAt"`
}

type DNSAccessPolicyAttributes struct {
	Bindings []*BindingAttributes `json:"bindings,omitempty"`
	ID       *string              `json:"id,omitempty"`
}

type DNSDomain struct {
	AccessPolicy *DNSAccessPolicy     `json:"accessPolicy"`
	Account      *Account             `json:"account"`
	Creator      *User                `json:"creator"`
	DNSRecords   *DNSRecordConnection `json:"dnsRecords"`
	ID           string               `json:"id"`
	InsertedAt   *string              `json:"insertedAt"`
	Name         string               `json:"name"`
	UpdatedAt    *string              `json:"updatedAt"`
}

type DNSDomainAttributes struct {
	AccessPolicy *DNSAccessPolicyAttributes `json:"accessPolicy,omitempty"`
	Name         *string                    `json:"name,omitempty"`
}

type DNSDomainConnection struct {
	Edges    []*DNSDomainEdge `json:"edges"`
	PageInfo PageInfo         `json:"pageInfo"`
}

type DNSDomainEdge struct {
	Cursor *string    `json:"cursor"`
	Node   *DNSDomain `json:"node"`
}

type DNSRecord struct {
	Cluster    string        `json:"cluster"`
	Creator    *User         `json:"creator"`
	Domain     *DNSDomain    `json:"domain"`
	ID         string        `json:"id"`
	InsertedAt *string       `json:"insertedAt"`
	Name       string        `json:"name"`
	Provider   Provider      `json:"provider"`
	Records    []*string     `json:"records"`
	Type       DNSRecordType `json:"type"`
	UpdatedAt  *string       `json:"updatedAt"`
}

type DNSRecordAttributes struct {
	Name    string        `json:"name"`
	Records []*string     `json:"records,omitempty"`
	Type    DNSRecordType `json:"type"`
}

type DNSRecordConnection struct {
	Edges    []*DNSRecordEdge `json:"edges"`
	PageInfo PageInfo         `json:"pageInfo"`
}

type DNSRecordEdge struct {
	Cursor *string    `json:"cursor"`
	Node   *DNSRecord `json:"node"`
}

type DockerImage struct {
	Digest           string            `json:"digest"`
	DockerRepository *DockerRepository `json:"dockerRepository"`
	Grade            *ImageGrade       `json:"grade"`
	ID               string            `json:"id"`
	InsertedAt       *string           `json:"insertedAt"`
	ScanCompletedAt  *string           `json:"scanCompletedAt"`
	ScannedAt        *string           `json:"scannedAt"`
	Tag              *string           `json:"tag"`
	UpdatedAt        *string           `json:"updatedAt"`
	Vulnerabilities  []*Vulnerability  `json:"vulnerabilities"`
}

type DockerImageConnection struct {
	Edges    []*DockerImageEdge `json:"edges"`
	PageInfo PageInfo           `json:"pageInfo"`
}

type DockerImageEdge struct {
	Cursor *string      `json:"cursor"`
	Node   *DockerImage `json:"node"`
}

type DockerRepository struct {
	ID         string      `json:"id"`
	InsertedAt *string     `json:"insertedAt"`
	Metrics    []*Metric   `json:"metrics"`
	Name       string      `json:"name"`
	Public     *bool       `json:"public"`
	Repository *Repository `json:"repository"`
	UpdatedAt  *string     `json:"updatedAt"`
}

type DockerRepositoryAttributes struct {
	Public bool `json:"public"`
}

type DockerRepositoryConnection struct {
	Edges    []*DockerRepositoryEdge `json:"edges"`
	PageInfo PageInfo                `json:"pageInfo"`
}

type DockerRepositoryEdge struct {
	Cursor *string           `json:"cursor"`
	Node   *DockerRepository `json:"node"`
}

type DomainMapping struct {
	Account    *Account `json:"account"`
	Domain     string   `json:"domain"`
	EnableSso  *bool    `json:"enableSso"`
	ID         string   `json:"id"`
	InsertedAt *string  `json:"insertedAt"`
	UpdatedAt  *string  `json:"updatedAt"`
}

type DomainMappingInput struct {
	Domain    *string `json:"domain,omitempty"`
	EnableSso *bool   `json:"enableSso,omitempty"`
	ID        *string `json:"id,omitempty"`
}

type EabCredential struct {
	Cluster    string   `json:"cluster"`
	HmacKey    string   `json:"hmacKey"`
	ID         string   `json:"id"`
	InsertedAt *string  `json:"insertedAt"`
	KeyID      string   `json:"keyId"`
	Provider   Provider `json:"provider"`
	UpdatedAt  *string  `json:"updatedAt"`
}

type EntityAttributes struct {
	EndIndex   *int64            `json:"endIndex,omitempty"`
	StartIndex *int64            `json:"startIndex,omitempty"`
	Text       *string           `json:"text,omitempty"`
	Type       MessageEntityType `json:"type"`
	UserID     *string           `json:"userId,omitempty"`
}

type File struct {
	Blob        string          `json:"blob"`
	ContentType *string         `json:"contentType"`
	Filename    *string         `json:"filename"`
	Filesize    *int64          `json:"filesize"`
	Height      *int64          `json:"height"`
	ID          string          `json:"id"`
	InsertedAt  *string         `json:"insertedAt"`
	MediaType   *MediaType      `json:"mediaType"`
	Message     IncidentMessage `json:"message"`
	UpdatedAt   *string         `json:"updatedAt"`
	Width       *int64          `json:"width"`
}

type FileAttributes struct {
	Blob *string `json:"blob,omitempty"`
}

type FileConnection struct {
	Edges    []*FileEdge `json:"edges"`
	PageInfo PageInfo    `json:"pageInfo"`
}

type FileContent struct {
	Content string `json:"content"`
	Path    string `json:"path"`
}

type FileEdge struct {
	Cursor *string `json:"cursor"`
	Node   *File   `json:"node"`
}

type Follower struct {
	ID          string                   `json:"id"`
	Incident    *Incident                `json:"incident"`
	InsertedAt  *string                  `json:"insertedAt"`
	Preferences *NotificationPreferences `json:"preferences"`
	UpdatedAt   *string                  `json:"updatedAt"`
	User        User                     `json:"user"`
}

type FollowerAttributes struct {
	Preferences *NotificationPreferencesAttributes `json:"preferences,omitempty"`
}

type FollowerConnection struct {
	Edges    []*FollowerEdge `json:"edges"`
	PageInfo PageInfo        `json:"pageInfo"`
}

type FollowerEdge struct {
	Cursor *string   `json:"cursor"`
	Node   *Follower `json:"node"`
}

type GcpShellCredentialsAttributes struct {
	ApplicationCredentials string `json:"applicationCredentials"`
}

type GeoMetric struct {
	Count   *int64  `json:"count"`
	Country *string `json:"country"`
}

type GitConfiguration struct {
	Branch *string `json:"branch"`
	Name   *string `json:"name"`
	Root   *string `json:"root"`
	URL    *string `json:"url"`
}

type Group struct {
	Description *string `json:"description"`
	Global      *bool   `json:"global"`
	ID          string  `json:"id"`
	InsertedAt  *string `json:"insertedAt"`
	Name        string  `json:"name"`
	UpdatedAt   *string `json:"updatedAt"`
}

type GroupAttributes struct {
	Description *string `json:"description,omitempty"`
	Global      *bool   `json:"global,omitempty"`
	Name        string  `json:"name"`
}

type GroupConnection struct {
	Edges    []*GroupEdge `json:"edges"`
	PageInfo PageInfo     `json:"pageInfo"`
}

type GroupEdge struct {
	Cursor *string `json:"cursor"`
	Node   *Group  `json:"node"`
}

type GroupMember struct {
	Group      *Group  `json:"group"`
	ID         string  `json:"id"`
	InsertedAt *string `json:"insertedAt"`
	UpdatedAt  *string `json:"updatedAt"`
	User       *User   `json:"user"`
}

type GroupMemberConnection struct {
	Edges    []*GroupMemberEdge `json:"edges"`
	PageInfo PageInfo           `json:"pageInfo"`
}

type GroupMemberEdge struct {
	Cursor *string      `json:"cursor"`
	Node   *GroupMember `json:"node"`
}

type GroupedTag struct {
	Count int64  `json:"count"`
	Tag   string `json:"tag"`
}

type GroupedTagConnection struct {
	Edges    []*GroupedTagEdge `json:"edges"`
	PageInfo PageInfo          `json:"pageInfo"`
}

type GroupedTagEdge struct {
	Cursor *string     `json:"cursor"`
	Node   *GroupedTag `json:"node"`
}

type ImageDependency struct {
	ID         string      `json:"id"`
	Image      DockerImage `json:"image"`
	InsertedAt *string     `json:"insertedAt"`
	UpdatedAt  *string     `json:"updatedAt"`
	Version    Version     `json:"version"`
}

type ImageLayer struct {
	DiffID *string `json:"diffId"`
	Digest *string `json:"digest"`
}

type ImpersonationPolicy struct {
	Bindings   []*ImpersonationPolicyBinding `json:"bindings"`
	ID         string                        `json:"id"`
	InsertedAt *string                       `json:"insertedAt"`
	UpdatedAt  *string                       `json:"updatedAt"`
}

type ImpersonationPolicyAttributes struct {
	Bindings []*ImpersonationPolicyBindingAttributes `json:"bindings,omitempty"`
	ID       *string                                 `json:"id,omitempty"`
}

type ImpersonationPolicyBinding struct {
	Group      *Group  `json:"group"`
	ID         string  `json:"id"`
	InsertedAt *string `json:"insertedAt"`
	UpdatedAt  *string `json:"updatedAt"`
	User       *User   `json:"user"`
}

type ImpersonationPolicyBindingAttributes struct {
	GroupID *string `json:"groupId,omitempty"`
	ID      *string `json:"id,omitempty"`
	UserID  *string `json:"userId,omitempty"`
}

type Incident struct {
	ClusterInformation *ClusterInformation        `json:"clusterInformation"`
	Creator            User                       `json:"creator"`
	Description        *string                    `json:"description"`
	Files              *FileConnection            `json:"files"`
	Follower           *Follower                  `json:"follower"`
	Followers          *FollowerConnection        `json:"followers"`
	History            *IncidentHistoryConnection `json:"history"`
	ID                 string                     `json:"id"`
	InsertedAt         *string                    `json:"insertedAt"`
	Messages           *IncidentMessageConnection `json:"messages"`
	NextResponseAt     *string                    `json:"nextResponseAt"`
	NotificationCount  *int64                     `json:"notificationCount"`
	Owner              *User                      `json:"owner"`
	Postmortem         *Postmortem                `json:"postmortem"`
	Repository         Repository                 `json:"repository"`
	Severity           int64                      `json:"severity"`
	Status             IncidentStatus             `json:"status"`
	Subscription       *SlimSubscription          `json:"subscription"`
	Tags               []*Tag                     `json:"tags"`
	Title              string                     `json:"title"`
	UpdatedAt          *string                    `json:"updatedAt"`
}

type IncidentAttributes struct {
	ClusterInformation *ClusterInformationAttributes `json:"clusterInformation,omitempty"`
	Description        *string                       `json:"description,omitempty"`
	Severity           *int64                        `json:"severity,omitempty"`
	Status             *IncidentStatus               `json:"status,omitempty"`
	Tags               []*TagAttributes              `json:"tags,omitempty"`
	Title              *string                       `json:"title,omitempty"`
}

type IncidentChange struct {
	Key  string  `json:"key"`
	Next *string `json:"next"`
	Prev *string `json:"prev"`
}

type IncidentConnection struct {
	Edges    []*IncidentEdge `json:"edges"`
	PageInfo PageInfo        `json:"pageInfo"`
}

type IncidentDelta struct {
	Delta   *Delta    `json:"delta"`
	Payload *Incident `json:"payload"`
}

type IncidentEdge struct {
	Cursor *string   `json:"cursor"`
	Node   *Incident `json:"node"`
}

type IncidentFilter struct {
	Statuses []*IncidentStatus  `json:"statuses,omitempty"`
	Type     IncidentFilterType `json:"type"`
	Value    *string            `json:"value,omitempty"`
}

type IncidentHistory struct {
	Action     IncidentAction    `json:"action"`
	Actor      User              `json:"actor"`
	Changes    []*IncidentChange `json:"changes"`
	ID         string            `json:"id"`
	Incident   Incident          `json:"incident"`
	InsertedAt *string           `json:"insertedAt"`
	UpdatedAt  *string           `json:"updatedAt"`
}

type IncidentHistoryConnection struct {
	Edges    []*IncidentHistoryEdge `json:"edges"`
	PageInfo PageInfo               `json:"pageInfo"`
}

type IncidentHistoryEdge struct {
	Cursor *string          `json:"cursor"`
	Node   *IncidentHistory `json:"node"`
}

type IncidentMessage struct {
	Creator    User             `json:"creator"`
	Entities   []*MessageEntity `json:"entities"`
	File       *File            `json:"file"`
	ID         string           `json:"id"`
	Incident   Incident         `json:"incident"`
	InsertedAt *string          `json:"insertedAt"`
	Reactions  []*Reaction      `json:"reactions"`
	Text       string           `json:"text"`
	UpdatedAt  *string          `json:"updatedAt"`
}

type IncidentMessageAttributes struct {
	Entities []*EntityAttributes `json:"entities,omitempty"`
	File     *FileAttributes     `json:"file,omitempty"`
	Text     string              `json:"text"`
}

type IncidentMessageConnection struct {
	Edges    []*IncidentMessageEdge `json:"edges"`
	PageInfo PageInfo               `json:"pageInfo"`
}

type IncidentMessageDelta struct {
	Delta   *Delta           `json:"delta"`
	Payload *IncidentMessage `json:"payload"`
}

type IncidentMessageEdge struct {
	Cursor *string          `json:"cursor"`
	Node   *IncidentMessage `json:"node"`
}

type Installation struct {
	AcmeKeyID    *string                 `json:"acmeKeyId"`
	AcmeSecret   *string                 `json:"acmeSecret"`
	AutoUpgrade  *bool                   `json:"autoUpgrade"`
	Context      map[string]interface{}  `json:"context"`
	ID           string                  `json:"id"`
	InsertedAt   *string                 `json:"insertedAt"`
	License      *string                 `json:"license"`
	LicenseKey   *string                 `json:"licenseKey"`
	OidcProvider *OidcProvider           `json:"oidcProvider"`
	Repository   *Repository             `json:"repository"`
	Subscription *RepositorySubscription `json:"subscription"`
	TrackTag     string                  `json:"trackTag"`
	UpdatedAt    *string                 `json:"updatedAt"`
	User         *User                   `json:"user"`
}

type InstallationAttributes struct {
	AutoUpgrade *bool   `json:"autoUpgrade,omitempty"`
	Context     *string `json:"context,omitempty"`
	TrackTag    *string `json:"trackTag,omitempty"`
}

type InstallationConnection struct {
	Edges    []*InstallationEdge `json:"edges"`
	PageInfo PageInfo            `json:"pageInfo"`
}

type InstallationEdge struct {
	Cursor *string       `json:"cursor"`
	Node   *Installation `json:"node"`
}

type Integration struct {
	Description *string                `json:"description"`
	Icon        *string                `json:"icon"`
	ID          string                 `json:"id"`
	InsertedAt  *string                `json:"insertedAt"`
	Name        string                 `json:"name"`
	Publisher   *Publisher             `json:"publisher"`
	Repository  *Repository            `json:"repository"`
	SourceURL   *string                `json:"sourceUrl"`
	Spec        map[string]interface{} `json:"spec"`
	Tags        []*Tag                 `json:"tags"`
	Type        *string                `json:"type"`
	UpdatedAt   *string                `json:"updatedAt"`
}

type IntegrationAttributes struct {
	Description *string          `json:"description,omitempty"`
	Icon        *string          `json:"icon,omitempty"`
	Name        string           `json:"name"`
	SourceURL   *string          `json:"sourceUrl,omitempty"`
	Spec        *string          `json:"spec,omitempty"`
	Tags        []*TagAttributes `json:"tags,omitempty"`
	Type        *string          `json:"type,omitempty"`
}

type IntegrationConnection struct {
	Edges    []*IntegrationEdge `json:"edges"`
	PageInfo PageInfo           `json:"pageInfo"`
}

type IntegrationEdge struct {
	Cursor *string      `json:"cursor"`
	Node   *Integration `json:"node"`
}

type IntegrationWebhook struct {
	Account    *Account              `json:"account"`
	Actions    []*string             `json:"actions"`
	ID         string                `json:"id"`
	InsertedAt *string               `json:"insertedAt"`
	Logs       *WebhookLogConnection `json:"logs"`
	Name       string                `json:"name"`
	Secret     string                `json:"secret"`
	UpdatedAt  *string               `json:"updatedAt"`
	URL        string                `json:"url"`
}

type IntegrationWebhookAttributes struct {
	Actions []*string `json:"actions,omitempty"`
	Name    string    `json:"name"`
	URL     string    `json:"url"`
}

type IntegrationWebhookConnection struct {
	Edges    []*IntegrationWebhookEdge `json:"edges"`
	PageInfo PageInfo                  `json:"pageInfo"`
}

type IntegrationWebhookEdge struct {
	Cursor *string             `json:"cursor"`
	Node   *IntegrationWebhook `json:"node"`
}

type Invite struct {
	Account    *Account `json:"account"`
	Email      *string  `json:"email"`
	Existing   bool     `json:"existing"`
	ExpiresAt  *string  `json:"expiresAt"`
	ID         string   `json:"id"`
	InsertedAt *string  `json:"insertedAt"`
	SecureID   *string  `json:"secureId"`
	UpdatedAt  *string  `json:"updatedAt"`
	User       *User    `json:"user"`
}

type InviteAttributes struct {
	Email *string `json:"email,omitempty"`
}

type InviteConnection struct {
	Edges    []*InviteEdge `json:"edges"`
	PageInfo PageInfo      `json:"pageInfo"`
}

type InviteEdge struct {
	Cursor *string `json:"cursor"`
	Node   *Invite `json:"node"`
}

type Invoice struct {
	AmountDue        int64          `json:"amountDue"`
	AmountPaid       int64          `json:"amountPaid"`
	CreatedAt        *string        `json:"createdAt"`
	Currency         string         `json:"currency"`
	HostedInvoiceURL *string        `json:"hostedInvoiceUrl"`
	Lines            []*InvoiceItem `json:"lines"`
	Number           string         `json:"number"`
	Status           *string        `json:"status"`
}

type InvoiceConnection struct {
	Edges    []*InvoiceEdge `json:"edges"`
	PageInfo PageInfo       `json:"pageInfo"`
}

type InvoiceEdge struct {
	Cursor *string  `json:"cursor"`
	Node   *Invoice `json:"node"`
}

type InvoiceItem struct {
	Amount      int64   `json:"amount"`
	Currency    string  `json:"currency"`
	Description *string `json:"description"`
}

type KeyBackup struct {
	ID           string    `json:"id"`
	InsertedAt   *string   `json:"insertedAt"`
	Name         string    `json:"name"`
	Repositories []*string `json:"repositories"`
	UpdatedAt    *string   `json:"updatedAt"`
	User         User      `json:"user"`
	Value        string    `json:"value"`
}

type KeyBackupAttributes struct {
	Key          string    `json:"key"`
	Name         string    `json:"name"`
	Repositories []*string `json:"repositories,omitempty"`
}

type KeyBackupConnection struct {
	Edges    []*KeyBackupEdge `json:"edges"`
	PageInfo PageInfo         `json:"pageInfo"`
}

type KeyBackupEdge struct {
	Cursor *string    `json:"cursor"`
	Node   *KeyBackup `json:"node"`
}

type License struct {
	Name *string `json:"name"`
	URL  *string `json:"url"`
}

type Limit struct {
	Dimension string `json:"dimension"`
	Quantity  int64  `json:"quantity"`
}

type LimitAttributes struct {
	Dimension string `json:"dimension"`
	Quantity  int64  `json:"quantity"`
}

type LineItem struct {
	Cost      int64     `json:"cost"`
	Dimension string    `json:"dimension"`
	Name      string    `json:"name"`
	Period    *string   `json:"period"`
	Type      *PlanType `json:"type"`
}

type LineItemAttributes struct {
	Cost      int64     `json:"cost"`
	Dimension string    `json:"dimension"`
	Name      string    `json:"name"`
	Period    string    `json:"period"`
	Type      *PlanType `json:"type,omitempty"`
}

type LockAttributes struct {
	Lock string `json:"lock"`
}

type LoginMethodResponse struct {
	AuthorizeURL *string     `json:"authorizeUrl"`
	LoginMethod  LoginMethod `json:"loginMethod"`
	Token        *string     `json:"token"`
}

type LoginRequest struct {
	RequestedScope []*string `json:"requestedScope"`
	Subject        *string   `json:"subject"`
}

type MeetingAttributes struct {
	IncidentID *string `json:"incidentId,omitempty"`
	Topic      string  `json:"topic"`
}

type MessageEntity struct {
	EndIndex   *int64            `json:"endIndex"`
	ID         string            `json:"id"`
	InsertedAt *string           `json:"insertedAt"`
	StartIndex *int64            `json:"startIndex"`
	Text       *string           `json:"text"`
	Type       MessageEntityType `json:"type"`
	UpdatedAt  *string           `json:"updatedAt"`
	User       *User             `json:"user"`
}

type Metric struct {
	Name   string         `json:"name"`
	Tags   []*MetricTag   `json:"tags"`
	Values []*MetricValue `json:"values"`
}

type MetricTag struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

type MetricValue struct {
	Time  *string `json:"time"`
	Value *int64  `json:"value"`
}

type NetworkConfiguration struct {
	PluralDNS *bool   `json:"pluralDns"`
	Subdomain *string `json:"subdomain"`
}

type Notification struct {
	Actor      User             `json:"actor"`
	ID         string           `json:"id"`
	Incident   *Incident        `json:"incident"`
	InsertedAt *string          `json:"insertedAt"`
	Message    *IncidentMessage `json:"message"`
	Msg        *string          `json:"msg"`
	Repository *Repository      `json:"repository"`
	Type       NotificationType `json:"type"`
	UpdatedAt  *string          `json:"updatedAt"`
	User       User             `json:"user"`
}

type NotificationConnection struct {
	Edges    []*NotificationEdge `json:"edges"`
	PageInfo PageInfo            `json:"pageInfo"`
}

type NotificationEdge struct {
	Cursor *string       `json:"cursor"`
	Node   *Notification `json:"node"`
}

type NotificationPreferences struct {
	IncidentUpdate *bool `json:"incidentUpdate"`
	Mention        *bool `json:"mention"`
	Message        *bool `json:"message"`
}

type NotificationPreferencesAttributes struct {
	IncidentUpdate bool `json:"incidentUpdate"`
	Mention        bool `json:"mention"`
	Message        bool `json:"message"`
}

type OauthAttributes struct {
	Code        *string       `json:"code,omitempty"`
	RedirectURI *string       `json:"redirectUri,omitempty"`
	Service     *OauthService `json:"service,omitempty"`
}

type OauthInfo struct {
	AuthorizeURL string        `json:"authorizeUrl"`
	Provider     OauthProvider `json:"provider"`
}

type OauthIntegration struct {
	Account    *Account     `json:"account"`
	ID         string       `json:"id"`
	InsertedAt *string      `json:"insertedAt"`
	Service    OauthService `json:"service"`
	UpdatedAt  *string      `json:"updatedAt"`
}

type OauthResponse struct {
	RedirectTo string `json:"redirectTo"`
}

type OauthSettings struct {
	AuthMethod OidcAuthMethod `json:"authMethod"`
	URIFormat  string         `json:"uriFormat"`
}

type OauthSettingsAttributes struct {
	AuthMethod OidcAuthMethod `json:"authMethod"`
	URIFormat  string         `json:"uriFormat"`
}

type OidcAttributes struct {
	AuthMethod   OidcAuthMethod       `json:"authMethod"`
	Bindings     []*BindingAttributes `json:"bindings,omitempty"`
	RedirectUris []*string            `json:"redirectUris,omitempty"`
}

type OidcLogin struct {
	City       *string     `json:"city"`
	Country    *string     `json:"country"`
	ID         string      `json:"id"`
	InsertedAt *string     `json:"insertedAt"`
	IP         *string     `json:"ip"`
	Latitude   *string     `json:"latitude"`
	Longitude  *string     `json:"longitude"`
	Owner      *User       `json:"owner"`
	Repository *Repository `json:"repository"`
	UpdatedAt  *string     `json:"updatedAt"`
	User       *User       `json:"user"`
}

type OidcLoginConnection struct {
	Edges    []*OidcLoginEdge `json:"edges"`
	PageInfo PageInfo         `json:"pageInfo"`
}

type OidcLoginEdge struct {
	Cursor *string    `json:"cursor"`
	Node   *OidcLogin `json:"node"`
}

type OidcProvider struct {
	AuthMethod    OidcAuthMethod         `json:"authMethod"`
	Bindings      []*OidcProviderBinding `json:"bindings"`
	ClientID      string                 `json:"clientId"`
	ClientSecret  string                 `json:"clientSecret"`
	Configuration *OuathConfiguration    `json:"configuration"`
	Consent       *ConsentRequest        `json:"consent"`
	ID            string                 `json:"id"`
	InsertedAt    *string                `json:"insertedAt"`
	RedirectUris  []*string              `json:"redirectUris"`
	UpdatedAt     *string                `json:"updatedAt"`
}

type OidcProviderBinding struct {
	Group      *Group  `json:"group"`
	ID         string  `json:"id"`
	InsertedAt *string `json:"insertedAt"`
	UpdatedAt  *string `json:"updatedAt"`
	User       *User   `json:"user"`
}

type OidcSettings struct {
	AuthMethod OidcAuthMethod `json:"authMethod"`
	DomainKey  *string        `json:"domainKey"`
	Subdomain  *bool          `json:"subdomain"`
	URIFormat  *string        `json:"uriFormat"`
	URIFormats []*string      `json:"uriFormats"`
}

type OidcSettingsAttributes struct {
	AuthMethod OidcAuthMethod `json:"authMethod"`
	DomainKey  *string        `json:"domainKey,omitempty"`
	Subdomain  *bool          `json:"subdomain,omitempty"`
	URIFormat  *string        `json:"uriFormat,omitempty"`
	URIFormats []*string      `json:"uriFormats,omitempty"`
}

type OidcStepResponse struct {
	Consent    *ConsentRequest `json:"consent"`
	Login      *LoginRequest   `json:"login"`
	Repository *Repository     `json:"repository"`
}

type OnboardingChecklist struct {
	Dismissed *bool                     `json:"dismissed"`
	Status    *OnboardingChecklistState `json:"status"`
}

type OnboardingChecklistAttributes struct {
	Dismissed *bool                     `json:"dismissed,omitempty"`
	Status    *OnboardingChecklistState `json:"status,omitempty"`
}

type OuathConfiguration struct {
	AuthorizationEndpoint *string `json:"authorizationEndpoint"`
	Issuer                *string `json:"issuer"`
	JwksURI               *string `json:"jwksUri"`
	TokenEndpoint         *string `json:"tokenEndpoint"`
	UserinfoEndpoint      *string `json:"userinfoEndpoint"`
}

type PackageScan struct {
	Errors     []*ScanError     `json:"errors"`
	Grade      *ImageGrade      `json:"grade"`
	ID         string           `json:"id"`
	InsertedAt *string          `json:"insertedAt"`
	UpdatedAt  *string          `json:"updatedAt"`
	Violations []*ScanViolation `json:"violations"`
}

type PageInfo struct {
	// When paginating forwards, the cursor to continue.
	EndCursor *string `json:"endCursor"`
	// When paginating forwards, are there more items?
	HasNextPage bool `json:"hasNextPage"`
	// When paginating backwards, are there more items?
	HasPreviousPage bool `json:"hasPreviousPage"`
	// When paginating backwards, the cursor to continue.
	StartCursor *string `json:"startCursor"`
}

type PersistedToken struct {
	Audits     *PersistedTokenAuditConnection `json:"audits"`
	ID         *string                        `json:"id"`
	InsertedAt *string                        `json:"insertedAt"`
	Metrics    []*GeoMetric                   `json:"metrics"`
	Token      *string                        `json:"token"`
	UpdatedAt  *string                        `json:"updatedAt"`
}

type PersistedTokenAudit struct {
	City       *string `json:"city"`
	Count      *int64  `json:"count"`
	Country    *string `json:"country"`
	ID         *string `json:"id"`
	InsertedAt *string `json:"insertedAt"`
	IP         *string `json:"ip"`
	Latitude   *string `json:"latitude"`
	Longitude  *string `json:"longitude"`
	Timestamp  *string `json:"timestamp"`
	UpdatedAt  *string `json:"updatedAt"`
}

type PersistedTokenAuditConnection struct {
	Edges    []*PersistedTokenAuditEdge `json:"edges"`
	PageInfo PageInfo                   `json:"pageInfo"`
}

type PersistedTokenAuditEdge struct {
	Cursor *string              `json:"cursor"`
	Node   *PersistedTokenAudit `json:"node"`
}

type PersistedTokenConnection struct {
	Edges    []*PersistedTokenEdge `json:"edges"`
	PageInfo PageInfo              `json:"pageInfo"`
}

type PersistedTokenEdge struct {
	Cursor *string         `json:"cursor"`
	Node   *PersistedToken `json:"node"`
}

type Plan struct {
	Cost          int64           `json:"cost"`
	Default       *bool           `json:"default"`
	ID            string          `json:"id"`
	InsertedAt    *string         `json:"insertedAt"`
	LineItems     *PlanLineItems  `json:"lineItems"`
	Metadata      *PlanMetadata   `json:"metadata"`
	Name          string          `json:"name"`
	Period        *string         `json:"period"`
	ServiceLevels []*ServiceLevel `json:"serviceLevels"`
	UpdatedAt     *string         `json:"updatedAt"`
	Visible       bool            `json:"visible"`
}

type PlanAttributes struct {
	Cost          int64                     `json:"cost"`
	Default       *bool                     `json:"default,omitempty"`
	LineItems     *PlanLineItemAttributes   `json:"lineItems,omitempty"`
	Metadata      *PlanMetadataAttributes   `json:"metadata,omitempty"`
	Name          string                    `json:"name"`
	Period        string                    `json:"period"`
	ServiceLevels []*ServiceLevelAttributes `json:"serviceLevels,omitempty"`
}

type PlanFeature struct {
	Description string `json:"description"`
	Name        string `json:"name"`
}

type PlanFeatureAttributes struct {
	Description string `json:"description"`
	Name        string `json:"name"`
}

type PlanLineItemAttributes struct {
	Included []*LimitAttributes    `json:"included,omitempty"`
	Items    []*LineItemAttributes `json:"items,omitempty"`
}

type PlanLineItems struct {
	Included []*Limit    `json:"included"`
	Items    []*LineItem `json:"items"`
}

type PlanMetadata struct {
	Features []*PlanFeature         `json:"features"`
	Freeform map[string]interface{} `json:"freeform"`
}

type PlanMetadataAttributes struct {
	Features []*PlanFeatureAttributes `json:"features,omitempty"`
	Freeform *string                  `json:"freeform,omitempty"`
}

type PlatformMetrics struct {
	Clusters     *int64 `json:"clusters"`
	Publishers   *int64 `json:"publishers"`
	Repositories *int64 `json:"repositories"`
	Rollouts     *int64 `json:"rollouts"`
}

type PluralConfiguration struct {
	GitCommit            *string `json:"gitCommit"`
	Registry             *string `json:"registry"`
	StripeConnectID      *string `json:"stripeConnectId"`
	StripePublishableKey *string `json:"stripePublishableKey"`
}

type PolicyBinding struct {
	Group      *Group  `json:"group"`
	ID         string  `json:"id"`
	InsertedAt *string `json:"insertedAt"`
	UpdatedAt  *string `json:"updatedAt"`
	User       *User   `json:"user"`
}

type Postmortem struct {
	ActionItems []*ActionItem `json:"actionItems"`
	Content     string        `json:"content"`
	Creator     User          `json:"creator"`
	ID          string        `json:"id"`
	InsertedAt  *string       `json:"insertedAt"`
	UpdatedAt   *string       `json:"updatedAt"`
}

type PostmortemAttributes struct {
	ActionItems []*ActionItemAttributes `json:"actionItems,omitempty"`
	Content     string                  `json:"content"`
}

type PublicKey struct {
	Content    string  `json:"content"`
	Digest     string  `json:"digest"`
	ID         string  `json:"id"`
	InsertedAt *string `json:"insertedAt"`
	Name       string  `json:"name"`
	UpdatedAt  *string `json:"updatedAt"`
	User       User    `json:"user"`
}

type PublicKeyAttributes struct {
	Content string `json:"content"`
	Name    string `json:"name"`
}

type PublicKeyConnection struct {
	Edges    []*PublicKeyEdge `json:"edges"`
	PageInfo PageInfo         `json:"pageInfo"`
}

type PublicKeyEdge struct {
	Cursor *string    `json:"cursor"`
	Node   *PublicKey `json:"node"`
}

type Publisher struct {
	Address          *Address      `json:"address"`
	Avatar           *string       `json:"avatar"`
	BackgroundColor  *string       `json:"backgroundColor"`
	BillingAccountID *string       `json:"billingAccountId"`
	Community        *Community    `json:"community"`
	Description      *string       `json:"description"`
	ID               *string       `json:"id"`
	InsertedAt       *string       `json:"insertedAt"`
	Name             string        `json:"name"`
	Owner            *User         `json:"owner"`
	Phone            *string       `json:"phone"`
	Repositories     []*Repository `json:"repositories"`
	UpdatedAt        *string       `json:"updatedAt"`
}

type PublisherAttributes struct {
	Address     *AddressAttributes   `json:"address,omitempty"`
	Avatar      *string              `json:"avatar,omitempty"`
	Community   *CommunityAttributes `json:"community,omitempty"`
	Description *string              `json:"description,omitempty"`
	Name        *string              `json:"name,omitempty"`
	Phone       *string              `json:"phone,omitempty"`
}

type PublisherConnection struct {
	Edges    []*PublisherEdge `json:"edges"`
	PageInfo PageInfo         `json:"pageInfo"`
}

type PublisherEdge struct {
	Cursor *string    `json:"cursor"`
	Node   *Publisher `json:"node"`
}

type Reaction struct {
	Creator    User            `json:"creator"`
	InsertedAt *string         `json:"insertedAt"`
	Message    IncidentMessage `json:"message"`
	Name       string          `json:"name"`
	UpdatedAt  *string         `json:"updatedAt"`
}

type Recipe struct {
	Description        *string          `json:"description"`
	ID                 string           `json:"id"`
	InsertedAt         *string          `json:"insertedAt"`
	Name               string           `json:"name"`
	OidcSettings       *OidcSettings    `json:"oidcSettings"`
	Private            *bool            `json:"private"`
	Provider           *Provider        `json:"provider"`
	RecipeDependencies []*Recipe        `json:"recipeDependencies"`
	RecipeSections     []*RecipeSection `json:"recipeSections"`
	Repository         *Repository      `json:"repository"`
	Restricted         *bool            `json:"restricted"`
	Tests              []*RecipeTest    `json:"tests"`
	UpdatedAt          *string          `json:"updatedAt"`
}

type RecipeAttributes struct {
	Dependencies []*RecipeReference         `json:"dependencies,omitempty"`
	Description  *string                    `json:"description,omitempty"`
	Name         string                     `json:"name"`
	OidcSettings *OidcSettingsAttributes    `json:"oidcSettings,omitempty"`
	Private      *bool                      `json:"private,omitempty"`
	Provider     *Provider                  `json:"provider,omitempty"`
	Restricted   *bool                      `json:"restricted,omitempty"`
	Sections     []*RecipeSectionAttributes `json:"sections,omitempty"`
	Tests        []*RecipeTestAttributes    `json:"tests,omitempty"`
}

type RecipeCondition struct {
	Field     string    `json:"field"`
	Operation Operation `json:"operation"`
	Value     *string   `json:"value"`
}

type RecipeConditionAttributes struct {
	Field     string    `json:"field"`
	Operation Operation `json:"operation"`
	Value     *string   `json:"value,omitempty"`
}

type RecipeConfiguration struct {
	Args          []*string         `json:"args"`
	Condition     *RecipeCondition  `json:"condition"`
	Default       *string           `json:"default"`
	Documentation *string           `json:"documentation"`
	FunctionName  *string           `json:"functionName"`
	Longform      *string           `json:"longform"`
	Name          *string           `json:"name"`
	Optional      *bool             `json:"optional"`
	Placeholder   *string           `json:"placeholder"`
	Type          *Datatype         `json:"type"`
	Validation    *RecipeValidation `json:"validation"`
}

type RecipeConfigurationAttributes struct {
	Condition     *RecipeConditionAttributes  `json:"condition,omitempty"`
	Default       *string                     `json:"default,omitempty"`
	Documentation *string                     `json:"documentation,omitempty"`
	FunctionName  *string                     `json:"functionName,omitempty"`
	Longform      *string                     `json:"longform,omitempty"`
	Name          string                      `json:"name"`
	Optional      *bool                       `json:"optional,omitempty"`
	Placeholder   *string                     `json:"placeholder,omitempty"`
	Type          Datatype                    `json:"type"`
	Validation    *RecipeValidationAttributes `json:"validation,omitempty"`
}

type RecipeConnection struct {
	Edges    []*RecipeEdge `json:"edges"`
	PageInfo PageInfo      `json:"pageInfo"`
}

type RecipeEdge struct {
	Cursor *string `json:"cursor"`
	Node   *Recipe `json:"node"`
}

type RecipeItem struct {
	Chart         *Chart                 `json:"chart"`
	Configuration []*RecipeConfiguration `json:"configuration"`
	ID            *string                `json:"id"`
	InsertedAt    *string                `json:"insertedAt"`
	RecipeSection *RecipeSection         `json:"recipeSection"`
	Terraform     *Terraform             `json:"terraform"`
	UpdatedAt     *string                `json:"updatedAt"`
}

type RecipeItemAttributes struct {
	Configuration []*RecipeConfigurationAttributes `json:"configuration,omitempty"`
	Name          string                           `json:"name"`
	Type          RecipeItemType                   `json:"type"`
}

type RecipeReference struct {
	Name string `json:"name"`
	Repo string `json:"repo"`
}

type RecipeSection struct {
	Configuration []*RecipeConfiguration `json:"configuration"`
	ID            *string                `json:"id"`
	Index         *int64                 `json:"index"`
	InsertedAt    *string                `json:"insertedAt"`
	Recipe        *Recipe                `json:"recipe"`
	RecipeItems   []*RecipeItem          `json:"recipeItems"`
	Repository    *Repository            `json:"repository"`
	UpdatedAt     *string                `json:"updatedAt"`
}

type RecipeSectionAttributes struct {
	Configuration []*RecipeConfigurationAttributes `json:"configuration,omitempty"`
	Items         []*RecipeItemAttributes          `json:"items,omitempty"`
	Name          string                           `json:"name"`
}

type RecipeTest struct {
	Args    []*TestArgument `json:"args"`
	Message *string         `json:"message"`
	Name    string          `json:"name"`
	Type    TestType        `json:"type"`
}

type RecipeTestAttributes struct {
	Args    []*TestArgumentAttributes `json:"args,omitempty"`
	Message *string                   `json:"message,omitempty"`
	Name    string                    `json:"name"`
	Type    TestType                  `json:"type"`
}

type RecipeValidation struct {
	Message string         `json:"message"`
	Regex   *string        `json:"regex"`
	Type    ValidationType `json:"type"`
}

type RecipeValidationAttributes struct {
	Message string         `json:"message"`
	Regex   *string        `json:"regex,omitempty"`
	Type    ValidationType `json:"type"`
}

type Repository struct {
	Artifacts     []*Artifact            `json:"artifacts"`
	Category      *Category              `json:"category"`
	Community     *Community             `json:"community"`
	DarkIcon      *string                `json:"darkIcon"`
	DefaultTag    *string                `json:"defaultTag"`
	Description   *string                `json:"description"`
	Docs          []*FileContent         `json:"docs"`
	Documentation *string                `json:"documentation"`
	Editable      *bool                  `json:"editable"`
	GitURL        *string                `json:"gitUrl"`
	Homepage      *string                `json:"homepage"`
	Icon          *string                `json:"icon"`
	ID            string                 `json:"id"`
	InsertedAt    *string                `json:"insertedAt"`
	Installation  *Installation          `json:"installation"`
	License       *License               `json:"license"`
	MainBranch    *string                `json:"mainBranch"`
	Name          string                 `json:"name"`
	Notes         *string                `json:"notes"`
	OauthSettings *OauthSettings         `json:"oauthSettings"`
	Plans         []*Plan                `json:"plans"`
	Private       *bool                  `json:"private"`
	PublicKey     *string                `json:"publicKey"`
	Publisher     *Publisher             `json:"publisher"`
	Readme        *string                `json:"readme"`
	Recipes       []*Recipe              `json:"recipes"`
	Secrets       map[string]interface{} `json:"secrets"`
	Tags          []*Tag                 `json:"tags"`
	Trending      *bool                  `json:"trending"`
	UpdatedAt     *string                `json:"updatedAt"`
	Verified      *bool                  `json:"verified"`
}

type RepositoryAttributes struct {
	Category                      *Category                     `json:"category,omitempty"`
	Community                     *CommunityAttributes          `json:"community,omitempty"`
	DarkIcon                      *string                       `json:"darkIcon,omitempty"`
	DefaultTag                    *string                       `json:"defaultTag,omitempty"`
	Description                   *string                       `json:"description,omitempty"`
	Docs                          *string                       `json:"docs,omitempty"`
	Documentation                 *string                       `json:"documentation,omitempty"`
	GitURL                        *string                       `json:"gitUrl,omitempty"`
	Homepage                      *string                       `json:"homepage,omitempty"`
	Icon                          *string                       `json:"icon,omitempty"`
	IntegrationResourceDefinition *ResourceDefinitionAttributes `json:"integrationResourceDefinition,omitempty"`
	Name                          *string                       `json:"name,omitempty"`
	Notes                         *string                       `json:"notes,omitempty"`
	OauthSettings                 *OauthSettingsAttributes      `json:"oauthSettings,omitempty"`
	Private                       *bool                         `json:"private,omitempty"`
	Readme                        *string                       `json:"readme,omitempty"`
	Secrets                       *string                       `json:"secrets,omitempty"`
	Tags                          []*TagAttributes              `json:"tags,omitempty"`
	Trending                      *bool                         `json:"trending,omitempty"`
	Verified                      *bool                         `json:"verified,omitempty"`
}

type RepositoryConnection struct {
	Edges    []*RepositoryEdge `json:"edges"`
	PageInfo PageInfo          `json:"pageInfo"`
}

type RepositoryEdge struct {
	Cursor *string     `json:"cursor"`
	Node   *Repository `json:"node"`
}

type RepositorySubscription struct {
	CustomerID   *string                `json:"customerId"`
	ExternalID   *string                `json:"externalId"`
	ID           string                 `json:"id"`
	Installation *Installation          `json:"installation"`
	Invoices     *InvoiceConnection     `json:"invoices"`
	LineItems    *SubscriptionLineItems `json:"lineItems"`
	Plan         *Plan                  `json:"plan"`
}

type RepositorySubscriptionConnection struct {
	Edges    []*RepositorySubscriptionEdge `json:"edges"`
	PageInfo PageInfo                      `json:"pageInfo"`
}

type RepositorySubscriptionEdge struct {
	Cursor *string                 `json:"cursor"`
	Node   *RepositorySubscription `json:"node"`
}

type ResetToken struct {
	Email      string         `json:"email"`
	ExternalID string         `json:"externalId"`
	ID         string         `json:"id"`
	InsertedAt *string        `json:"insertedAt"`
	Type       ResetTokenType `json:"type"`
	UpdatedAt  *string        `json:"updatedAt"`
	User       User           `json:"user"`
}

type ResetTokenAttributes struct {
	Email *string        `json:"email,omitempty"`
	Type  ResetTokenType `json:"type"`
}

type ResetTokenRealization struct {
	Password *string `json:"password,omitempty"`
}

type ResourceDefinitionAttributes struct {
	Name string                     `json:"name"`
	Spec []*SpecificationAttributes `json:"spec,omitempty"`
}

type Role struct {
	Account      *Account       `json:"account"`
	Description  *string        `json:"description"`
	ID           string         `json:"id"`
	InsertedAt   *string        `json:"insertedAt"`
	Name         string         `json:"name"`
	Permissions  []*Permission  `json:"permissions"`
	Repositories []*string      `json:"repositories"`
	RoleBindings []*RoleBinding `json:"roleBindings"`
	UpdatedAt    *string        `json:"updatedAt"`
}

type RoleAttributes struct {
	Description  *string              `json:"description,omitempty"`
	Name         *string              `json:"name,omitempty"`
	Permissions  []*Permission        `json:"permissions,omitempty"`
	Repositories []*string            `json:"repositories,omitempty"`
	RoleBindings []*BindingAttributes `json:"roleBindings,omitempty"`
}

type RoleBinding struct {
	Group      *Group  `json:"group"`
	ID         string  `json:"id"`
	InsertedAt *string `json:"insertedAt"`
	UpdatedAt  *string `json:"updatedAt"`
	User       *User   `json:"user"`
}

type RoleConnection struct {
	Edges    []*RoleEdge `json:"edges"`
	PageInfo PageInfo    `json:"pageInfo"`
}

type RoleEdge struct {
	Cursor *string `json:"cursor"`
	Node   *Role   `json:"node"`
}

type Roles struct {
	Admin *bool `json:"admin"`
}

type RolesAttributes struct {
	Admin *bool `json:"admin,omitempty"`
}

type Rollout struct {
	Count      *int64        `json:"count"`
	Cursor     *string       `json:"cursor"`
	Event      *string       `json:"event"`
	Heartbeat  *string       `json:"heartbeat"`
	ID         string        `json:"id"`
	InsertedAt *string       `json:"insertedAt"`
	Repository *Repository   `json:"repository"`
	Status     RolloutStatus `json:"status"`
	UpdatedAt  *string       `json:"updatedAt"`
}

type RolloutConnection struct {
	Edges    []*RolloutEdge `json:"edges"`
	PageInfo PageInfo       `json:"pageInfo"`
}

type RolloutDelta struct {
	Delta   *Delta   `json:"delta"`
	Payload *Rollout `json:"payload"`
}

type RolloutEdge struct {
	Cursor *string  `json:"cursor"`
	Node   *Rollout `json:"node"`
}

type RootSubscriptionType struct {
	IncidentDelta        *IncidentDelta        `json:"incidentDelta"`
	IncidentMessageDelta *IncidentMessageDelta `json:"incidentMessageDelta"`
	Notification         *Notification         `json:"notification"`
	RolloutDelta         *RolloutDelta         `json:"rolloutDelta"`
	TestDelta            *TestDelta            `json:"testDelta"`
	TestLogs             *StepLogs             `json:"testLogs"`
	Upgrade              *Upgrade              `json:"upgrade"`
	UpgradeQueueDelta    *UpgradeQueueDelta    `json:"upgradeQueueDelta"`
}

type ScaffoldFile struct {
	Content *string `json:"content"`
	Path    *string `json:"path"`
}

type ScanError struct {
	Message *string `json:"message"`
}

type ScanViolation struct {
	Category     *string    `json:"category"`
	Description  *string    `json:"description"`
	File         *string    `json:"file"`
	InsertedAt   *string    `json:"insertedAt"`
	Line         *int64     `json:"line"`
	ResourceName *string    `json:"resourceName"`
	ResourceType *string    `json:"resourceType"`
	RuleID       *string    `json:"ruleId"`
	RuleName     *string    `json:"ruleName"`
	Severity     *VulnGrade `json:"severity"`
	UpdatedAt    *string    `json:"updatedAt"`
}

type ScmAttributes struct {
	Name     string       `json:"name"`
	Org      *string      `json:"org,omitempty"`
	Provider *ScmProvider `json:"provider,omitempty"`
	Token    string       `json:"token"`
}

type ServiceAccountAttributes struct {
	Email               *string                        `json:"email,omitempty"`
	ImpersonationPolicy *ImpersonationPolicyAttributes `json:"impersonationPolicy,omitempty"`
	Name                *string                        `json:"name,omitempty"`
}

type ServiceLevel struct {
	MaxSeverity  *int64 `json:"maxSeverity"`
	MinSeverity  *int64 `json:"minSeverity"`
	ResponseTime *int64 `json:"responseTime"`
}

type ServiceLevelAttributes struct {
	MaxSeverity  *int64 `json:"maxSeverity,omitempty"`
	MinSeverity  *int64 `json:"minSeverity,omitempty"`
	ResponseTime *int64 `json:"responseTime,omitempty"`
}

type ShellConfiguration struct {
	ContextConfiguration map[string]interface{} `json:"contextConfiguration"`
	Git                  *GitConfiguration      `json:"git"`
	Workspace            *ShellWorkspace        `json:"workspace"`
}

type ShellCredentialsAttributes struct {
	Aws   *AwsShellCredentialsAttributes   `json:"aws,omitempty"`
	Azure *AzureShellCredentialsAttributes `json:"azure,omitempty"`
	Gcp   *GcpShellCredentialsAttributes   `json:"gcp,omitempty"`
}

type ShellStatus struct {
	ContainersReady *bool `json:"containersReady"`
	Initialized     *bool `json:"initialized"`
	PodScheduled    *bool `json:"podScheduled"`
	Ready           *bool `json:"ready"`
}

type ShellWorkspace struct {
	BucketPrefix *string               `json:"bucketPrefix"`
	Cluster      *string               `json:"cluster"`
	Network      *NetworkConfiguration `json:"network"`
}

type SlimSubscription struct {
	ID        string                 `json:"id"`
	LineItems *SubscriptionLineItems `json:"lineItems"`
	Plan      *Plan                  `json:"plan"`
}

type SpecificationAttributes struct {
	Inner    *SpecDatatype              `json:"inner,omitempty"`
	Name     string                     `json:"name"`
	Required *bool                      `json:"required,omitempty"`
	Spec     []*SpecificationAttributes `json:"spec,omitempty"`
	Type     SpecDatatype               `json:"type"`
}

type Stack struct {
	Bundles     []*Recipe          `json:"bundles"`
	Collections []*StackCollection `json:"collections"`
	Community   *Community         `json:"community"`
	Creator     *User              `json:"creator"`
	Description *string            `json:"description"`
	DisplayName *string            `json:"displayName"`
	Featured    *bool              `json:"featured"`
	ID          string             `json:"id"`
	InsertedAt  *string            `json:"insertedAt"`
	Name        string             `json:"name"`
	UpdatedAt   *string            `json:"updatedAt"`
}

type StackAttributes struct {
	Collections []*StackCollectionAttributes `json:"collections,omitempty"`
	Community   *CommunityAttributes         `json:"community,omitempty"`
	Description *string                      `json:"description,omitempty"`
	DisplayName *string                      `json:"displayName,omitempty"`
	Featured    *bool                        `json:"featured,omitempty"`
	Name        string                       `json:"name"`
}

type StackCollection struct {
	Bundles    []*StackRecipe `json:"bundles"`
	ID         string         `json:"id"`
	InsertedAt *string        `json:"insertedAt"`
	Provider   Provider       `json:"provider"`
	UpdatedAt  *string        `json:"updatedAt"`
}

type StackCollectionAttributes struct {
	Bundles  []*RecipeReference `json:"bundles,omitempty"`
	Provider Provider           `json:"provider"`
}

type StackConnection struct {
	Edges    []*StackEdge `json:"edges"`
	PageInfo PageInfo     `json:"pageInfo"`
}

type StackEdge struct {
	Cursor *string `json:"cursor"`
	Node   *Stack  `json:"node"`
}

type StackRecipe struct {
	ID         string  `json:"id"`
	InsertedAt *string `json:"insertedAt"`
	Recipe     Recipe  `json:"recipe"`
	UpdatedAt  *string `json:"updatedAt"`
}

type StepLogs struct {
	Logs []*string `json:"logs"`
	Step *TestStep `json:"step"`
}

type SubscriptionAttributes struct {
	LineItems *SubscriptionLineItemAttributes `json:"lineItems,omitempty"`
}

type SubscriptionLineItemAttributes struct {
	Items []*LimitAttributes `json:"items,omitempty"`
}

type SubscriptionLineItems struct {
	Items []*Limit `json:"items"`
}

type Tag struct {
	ID  string `json:"id"`
	Tag string `json:"tag"`
}

type TagAttributes struct {
	Tag string `json:"tag"`
}

type Terraform struct {
	Dependencies   *Dependencies          `json:"dependencies"`
	Description    *string                `json:"description"`
	Editable       *bool                  `json:"editable"`
	ID             *string                `json:"id"`
	InsertedAt     *string                `json:"insertedAt"`
	Installation   *TerraformInstallation `json:"installation"`
	LatestVersion  *string                `json:"latestVersion"`
	Name           *string                `json:"name"`
	Package        *string                `json:"package"`
	Readme         *string                `json:"readme"`
	Repository     *Repository            `json:"repository"`
	UpdatedAt      *string                `json:"updatedAt"`
	ValuesTemplate *string                `json:"valuesTemplate"`
}

type TerraformAttributes struct {
	Dependencies *string `json:"dependencies,omitempty"`
	Description  *string `json:"description,omitempty"`
	Name         *string `json:"name,omitempty"`
	Package      *string `json:"package,omitempty"`
	Version      *string `json:"version,omitempty"`
}

type TerraformConnection struct {
	Edges    []*TerraformEdge `json:"edges"`
	PageInfo PageInfo         `json:"pageInfo"`
}

type TerraformEdge struct {
	Cursor *string    `json:"cursor"`
	Node   *Terraform `json:"node"`
}

type TerraformInstallation struct {
	ID           *string       `json:"id"`
	InsertedAt   *string       `json:"insertedAt"`
	Installation *Installation `json:"installation"`
	Terraform    *Terraform    `json:"terraform"`
	UpdatedAt    *string       `json:"updatedAt"`
	Version      *Version      `json:"version"`
}

type TerraformInstallationAttributes struct {
	TerraformID *string `json:"terraformId,omitempty"`
	VersionID   *string `json:"versionId,omitempty"`
}

type TerraformInstallationConnection struct {
	Edges    []*TerraformInstallationEdge `json:"edges"`
	PageInfo PageInfo                     `json:"pageInfo"`
}

type TerraformInstallationEdge struct {
	Cursor *string                `json:"cursor"`
	Node   *TerraformInstallation `json:"node"`
}

type TerraformProvider struct {
	Content *string   `json:"content"`
	Name    *Provider `json:"name"`
}

type Test struct {
	Creator    *User       `json:"creator"`
	ID         string      `json:"id"`
	InsertedAt *string     `json:"insertedAt"`
	Name       *string     `json:"name"`
	PromoteTag string      `json:"promoteTag"`
	Repository *Repository `json:"repository"`
	SourceTag  string      `json:"sourceTag"`
	Status     TestStatus  `json:"status"`
	Steps      []*TestStep `json:"steps"`
	UpdatedAt  *string     `json:"updatedAt"`
}

type TestArgument struct {
	Key  string `json:"key"`
	Name string `json:"name"`
	Repo string `json:"repo"`
}

type TestArgumentAttributes struct {
	Key  string `json:"key"`
	Name string `json:"name"`
	Repo string `json:"repo"`
}

type TestAttributes struct {
	Name       *string               `json:"name,omitempty"`
	PromoteTag *string               `json:"promoteTag,omitempty"`
	Status     *TestStatus           `json:"status,omitempty"`
	Steps      []*TestStepAttributes `json:"steps,omitempty"`
}

type TestConnection struct {
	Edges    []*TestEdge `json:"edges"`
	PageInfo PageInfo    `json:"pageInfo"`
}

type TestDelta struct {
	Delta   *Delta `json:"delta"`
	Payload *Test  `json:"payload"`
}

type TestEdge struct {
	Cursor *string `json:"cursor"`
	Node   *Test   `json:"node"`
}

type TestStep struct {
	Description string     `json:"description"`
	HasLogs     *bool      `json:"hasLogs"`
	ID          string     `json:"id"`
	InsertedAt  *string    `json:"insertedAt"`
	Name        string     `json:"name"`
	Status      TestStatus `json:"status"`
	UpdatedAt   *string    `json:"updatedAt"`
}

type TestStepAttributes struct {
	Description *string     `json:"description,omitempty"`
	ID          *string     `json:"id,omitempty"`
	Logs        *string     `json:"logs,omitempty"`
	Name        *string     `json:"name,omitempty"`
	Status      *TestStatus `json:"status,omitempty"`
}

type UpdatablePlanAttributes struct {
	Default       *bool                     `json:"default,omitempty"`
	ServiceLevels []*ServiceLevelAttributes `json:"serviceLevels,omitempty"`
}

type Upgrade struct {
	ID         string       `json:"id"`
	InsertedAt *string      `json:"insertedAt"`
	Message    *string      `json:"message"`
	Repository *Repository  `json:"repository"`
	Type       *UpgradeType `json:"type"`
	UpdatedAt  *string      `json:"updatedAt"`
}

type UpgradeConnection struct {
	Edges    []*UpgradeEdge `json:"edges"`
	PageInfo PageInfo       `json:"pageInfo"`
}

type UpgradeEdge struct {
	Cursor *string  `json:"cursor"`
	Node   *Upgrade `json:"node"`
}

type UpgradeQueue struct {
	Acked      *string            `json:"acked"`
	Domain     *string            `json:"domain"`
	Git        *string            `json:"git"`
	ID         string             `json:"id"`
	InsertedAt *string            `json:"insertedAt"`
	Name       *string            `json:"name"`
	PingedAt   *string            `json:"pingedAt"`
	Provider   *Provider          `json:"provider"`
	UpdatedAt  *string            `json:"updatedAt"`
	Upgrades   *UpgradeConnection `json:"upgrades"`
	User       User               `json:"user"`
}

type UpgradeQueueAttributes struct {
	Domain   *string   `json:"domain,omitempty"`
	Git      *string   `json:"git,omitempty"`
	Name     string    `json:"name"`
	Provider *Provider `json:"provider,omitempty"`
}

type UpgradeQueueDelta struct {
	Delta   *Delta        `json:"delta"`
	Payload *UpgradeQueue `json:"payload"`
}

type User struct {
	Account             *Account             `json:"account"`
	Address             *Address             `json:"address"`
	Avatar              *string              `json:"avatar"`
	BackgroundColor     *string              `json:"backgroundColor"`
	BoundRoles          []*Role              `json:"boundRoles"`
	Cards               *CardConnection      `json:"cards"`
	DefaultQueueID      *string              `json:"defaultQueueId"`
	Email               string               `json:"email"`
	EmailConfirmBy      *string              `json:"emailConfirmBy"`
	EmailConfirmed      *bool                `json:"emailConfirmed"`
	HasInstallations    *bool                `json:"hasInstallations"`
	ID                  string               `json:"id"`
	ImpersonationPolicy *ImpersonationPolicy `json:"impersonationPolicy"`
	InsertedAt          *string              `json:"insertedAt"`
	Jwt                 *string              `json:"jwt"`
	LoginMethod         *LoginMethod         `json:"loginMethod"`
	Name                string               `json:"name"`
	Onboarding          *OnboardingState     `json:"onboarding"`
	OnboardingChecklist *OnboardingChecklist `json:"onboardingChecklist"`
	Phone               *string              `json:"phone"`
	Provider            *Provider            `json:"provider"`
	Publisher           *Publisher           `json:"publisher"`
	Roles               *Roles               `json:"roles"`
	ServiceAccount      *bool                `json:"serviceAccount"`
	UpdatedAt           *string              `json:"updatedAt"`
}

type UserAttributes struct {
	Avatar              *string                        `json:"avatar,omitempty"`
	Confirm             *string                        `json:"confirm,omitempty"`
	Email               *string                        `json:"email,omitempty"`
	LoginMethod         *LoginMethod                   `json:"loginMethod,omitempty"`
	Name                *string                        `json:"name,omitempty"`
	Onboarding          *OnboardingState               `json:"onboarding,omitempty"`
	OnboardingChecklist *OnboardingChecklistAttributes `json:"onboardingChecklist,omitempty"`
	Password            *string                        `json:"password,omitempty"`
	Roles               *RolesAttributes               `json:"roles,omitempty"`
}

type UserConnection struct {
	Edges    []*UserEdge `json:"edges"`
	PageInfo PageInfo    `json:"pageInfo"`
}

type UserEdge struct {
	Cursor *string `json:"cursor"`
	Node   *User   `json:"node"`
}

type UserEventAttributes struct {
	Data   *string          `json:"data,omitempty"`
	Event  string           `json:"event"`
	Status *UserEventStatus `json:"status,omitempty"`
}

type Version struct {
	Chart             *Chart                 `json:"chart"`
	Crds              []*Crd                 `json:"crds"`
	Dependencies      *Dependencies          `json:"dependencies"`
	Helm              map[string]interface{} `json:"helm"`
	ID                string                 `json:"id"`
	ImageDependencies []*ImageDependency     `json:"imageDependencies"`
	InsertedAt        *string                `json:"insertedAt"`
	Package           *string                `json:"package"`
	Readme            *string                `json:"readme"`
	Scan              *PackageScan           `json:"scan"`
	Tags              []*VersionTag          `json:"tags"`
	Terraform         *Terraform             `json:"terraform"`
	UpdatedAt         *string                `json:"updatedAt"`
	ValuesTemplate    *string                `json:"valuesTemplate"`
	Version           string                 `json:"version"`
}

type VersionAttributes struct {
	Tags []*VersionTagAttributes `json:"tags,omitempty"`
}

type VersionConnection struct {
	Edges    []*VersionEdge `json:"edges"`
	PageInfo PageInfo       `json:"pageInfo"`
}

type VersionEdge struct {
	Cursor *string  `json:"cursor"`
	Node   *Version `json:"node"`
}

type VersionSpec struct {
	Chart      *string `json:"chart,omitempty"`
	Repository *string `json:"repository,omitempty"`
	Terraform  *string `json:"terraform,omitempty"`
	Version    *string `json:"version,omitempty"`
}

type VersionTag struct {
	Chart      *Chart   `json:"chart"`
	ID         string   `json:"id"`
	InsertedAt *string  `json:"insertedAt"`
	Tag        string   `json:"tag"`
	UpdatedAt  *string  `json:"updatedAt"`
	Version    *Version `json:"version"`
}

type VersionTagAttributes struct {
	Tag       string  `json:"tag"`
	VersionID *string `json:"versionId,omitempty"`
}

type Vulnerability struct {
	Cvss             *Cvss       `json:"cvss"`
	Description      *string     `json:"description"`
	FixedVersion     *string     `json:"fixedVersion"`
	ID               string      `json:"id"`
	InsertedAt       *string     `json:"insertedAt"`
	InstalledVersion *string     `json:"installedVersion"`
	Layer            *ImageLayer `json:"layer"`
	Package          *string     `json:"package"`
	Score            *float64    `json:"score"`
	Severity         *VulnGrade  `json:"severity"`
	Source           *string     `json:"source"`
	Title            *string     `json:"title"`
	UpdatedAt        *string     `json:"updatedAt"`
	URL              *string     `json:"url"`
	VulnerabilityID  *string     `json:"vulnerabilityId"`
}

type Webhook struct {
	ID         *string `json:"id"`
	InsertedAt *string `json:"insertedAt"`
	Secret     *string `json:"secret"`
	UpdatedAt  *string `json:"updatedAt"`
	URL        *string `json:"url"`
	User       *User   `json:"user"`
}

type WebhookAttributes struct {
	URL string `json:"url"`
}

type WebhookConnection struct {
	Edges    []*WebhookEdge `json:"edges"`
	PageInfo PageInfo       `json:"pageInfo"`
}

type WebhookEdge struct {
	Cursor *string  `json:"cursor"`
	Node   *Webhook `json:"node"`
}

type WebhookLog struct {
	ID         string                 `json:"id"`
	InsertedAt *string                `json:"insertedAt"`
	Payload    map[string]interface{} `json:"payload"`
	Response   *string                `json:"response"`
	State      WebhookLogState        `json:"state"`
	Status     *int64                 `json:"status"`
	UpdatedAt  *string                `json:"updatedAt"`
	Webhook    *IntegrationWebhook    `json:"webhook"`
}

type WebhookLogConnection struct {
	Edges    []*WebhookLogEdge `json:"edges"`
	PageInfo PageInfo          `json:"pageInfo"`
}

type WebhookLogEdge struct {
	Cursor *string     `json:"cursor"`
	Node   *WebhookLog `json:"node"`
}

type WebhookResponse struct {
	Body       *string                `json:"body"`
	Headers    map[string]interface{} `json:"headers"`
	StatusCode int64                  `json:"statusCode"`
}

type Wirings struct {
	Helm      map[string]interface{} `json:"helm"`
	Terraform map[string]interface{} `json:"terraform"`
}

type WorkspaceAttributes struct {
	BucketPrefix string  `json:"bucketPrefix"`
	Cluster      string  `json:"cluster"`
	Project      *string `json:"project,omitempty"`
	Region       string  `json:"region"`
	Subdomain    string  `json:"subdomain"`
}

type ZoomMeeting struct {
	JoinURL  string  `json:"joinUrl"`
	Password *string `json:"password"`
}

type ActionItemType string

const (
	ActionItemTypeBlog  ActionItemType = "BLOG"
	ActionItemTypeIssue ActionItemType = "ISSUE"
	ActionItemTypePull  ActionItemType = "PULL"
)

var AllActionItemType = []ActionItemType{
	ActionItemTypeBlog,
	ActionItemTypeIssue,
	ActionItemTypePull,
}

func (e ActionItemType) IsValid() bool {
	switch e {
	case ActionItemTypeBlog, ActionItemTypeIssue, ActionItemTypePull:
		return true
	}
	return false
}

func (e ActionItemType) String() string {
	return string(e)
}

func (e *ActionItemType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ActionItemType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ActionItemType", str)
	}
	return nil
}

func (e ActionItemType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ArtifactPlatform string

const (
	ArtifactPlatformAndroid ArtifactPlatform = "ANDROID"
	ArtifactPlatformFreebsd ArtifactPlatform = "FREEBSD"
	ArtifactPlatformLinux   ArtifactPlatform = "LINUX"
	ArtifactPlatformMac     ArtifactPlatform = "MAC"
	ArtifactPlatformOpenbsd ArtifactPlatform = "OPENBSD"
	ArtifactPlatformSolaris ArtifactPlatform = "SOLARIS"
	ArtifactPlatformWindows ArtifactPlatform = "WINDOWS"
)

var AllArtifactPlatform = []ArtifactPlatform{
	ArtifactPlatformAndroid,
	ArtifactPlatformFreebsd,
	ArtifactPlatformLinux,
	ArtifactPlatformMac,
	ArtifactPlatformOpenbsd,
	ArtifactPlatformSolaris,
	ArtifactPlatformWindows,
}

func (e ArtifactPlatform) IsValid() bool {
	switch e {
	case ArtifactPlatformAndroid, ArtifactPlatformFreebsd, ArtifactPlatformLinux, ArtifactPlatformMac, ArtifactPlatformOpenbsd, ArtifactPlatformSolaris, ArtifactPlatformWindows:
		return true
	}
	return false
}

func (e ArtifactPlatform) String() string {
	return string(e)
}

func (e *ArtifactPlatform) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ArtifactPlatform(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ArtifactPlatform", str)
	}
	return nil
}

func (e ArtifactPlatform) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ArtifactType string

const (
	ArtifactTypeCli     ArtifactType = "CLI"
	ArtifactTypeDesktop ArtifactType = "DESKTOP"
	ArtifactTypeMobile  ArtifactType = "MOBILE"
)

var AllArtifactType = []ArtifactType{
	ArtifactTypeCli,
	ArtifactTypeDesktop,
	ArtifactTypeMobile,
}

func (e ArtifactType) IsValid() bool {
	switch e {
	case ArtifactTypeCli, ArtifactTypeDesktop, ArtifactTypeMobile:
		return true
	}
	return false
}

func (e ArtifactType) String() string {
	return string(e)
}

func (e *ArtifactType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ArtifactType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ArtifactType", str)
	}
	return nil
}

func (e ArtifactType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Category string

const (
	CategoryData         Category = "DATA"
	CategoryDatabase     Category = "DATABASE"
	CategoryDevops       Category = "DEVOPS"
	CategoryMessaging    Category = "MESSAGING"
	CategoryNetwork      Category = "NETWORK"
	CategoryProductivity Category = "PRODUCTIVITY"
	CategorySecurity     Category = "SECURITY"
	CategoryStorage      Category = "STORAGE"
)

var AllCategory = []Category{
	CategoryData,
	CategoryDatabase,
	CategoryDevops,
	CategoryMessaging,
	CategoryNetwork,
	CategoryProductivity,
	CategorySecurity,
	CategoryStorage,
}

func (e Category) IsValid() bool {
	switch e {
	case CategoryData, CategoryDatabase, CategoryDevops, CategoryMessaging, CategoryNetwork, CategoryProductivity, CategorySecurity, CategoryStorage:
		return true
	}
	return false
}

func (e Category) String() string {
	return string(e)
}

func (e *Category) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Category(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Category", str)
	}
	return nil
}

func (e Category) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Datatype string

const (
	DatatypeBool     Datatype = "BOOL"
	DatatypeBucket   Datatype = "BUCKET"
	DatatypeDomain   Datatype = "DOMAIN"
	DatatypeFile     Datatype = "FILE"
	DatatypeFunction Datatype = "FUNCTION"
	DatatypeInt      Datatype = "INT"
	DatatypePassword Datatype = "PASSWORD"
	DatatypeString   Datatype = "STRING"
)

var AllDatatype = []Datatype{
	DatatypeBool,
	DatatypeBucket,
	DatatypeDomain,
	DatatypeFile,
	DatatypeFunction,
	DatatypeInt,
	DatatypePassword,
	DatatypeString,
}

func (e Datatype) IsValid() bool {
	switch e {
	case DatatypeBool, DatatypeBucket, DatatypeDomain, DatatypeFile, DatatypeFunction, DatatypeInt, DatatypePassword, DatatypeString:
		return true
	}
	return false
}

func (e Datatype) String() string {
	return string(e)
}

func (e *Datatype) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Datatype(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Datatype", str)
	}
	return nil
}

func (e Datatype) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Delta string

const (
	DeltaCreate Delta = "CREATE"
	DeltaDelete Delta = "DELETE"
	DeltaUpdate Delta = "UPDATE"
)

var AllDelta = []Delta{
	DeltaCreate,
	DeltaDelete,
	DeltaUpdate,
}

func (e Delta) IsValid() bool {
	switch e {
	case DeltaCreate, DeltaDelete, DeltaUpdate:
		return true
	}
	return false
}

func (e Delta) String() string {
	return string(e)
}

func (e *Delta) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Delta(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Delta", str)
	}
	return nil
}

func (e Delta) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DemoProjectState string

const (
	DemoProjectStateCreated DemoProjectState = "CREATED"
	DemoProjectStateEnabled DemoProjectState = "ENABLED"
	DemoProjectStateReady   DemoProjectState = "READY"
)

var AllDemoProjectState = []DemoProjectState{
	DemoProjectStateCreated,
	DemoProjectStateEnabled,
	DemoProjectStateReady,
}

func (e DemoProjectState) IsValid() bool {
	switch e {
	case DemoProjectStateCreated, DemoProjectStateEnabled, DemoProjectStateReady:
		return true
	}
	return false
}

func (e DemoProjectState) String() string {
	return string(e)
}

func (e *DemoProjectState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DemoProjectState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DemoProjectState", str)
	}
	return nil
}

func (e DemoProjectState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DependencyType string

const (
	DependencyTypeHelm      DependencyType = "HELM"
	DependencyTypeTerraform DependencyType = "TERRAFORM"
)

var AllDependencyType = []DependencyType{
	DependencyTypeHelm,
	DependencyTypeTerraform,
}

func (e DependencyType) IsValid() bool {
	switch e {
	case DependencyTypeHelm, DependencyTypeTerraform:
		return true
	}
	return false
}

func (e DependencyType) String() string {
	return string(e)
}

func (e *DependencyType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DependencyType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DependencyType", str)
	}
	return nil
}

func (e DependencyType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DNSRecordType string

const (
	DNSRecordTypeA     DNSRecordType = "A"
	DNSRecordTypeAaaa  DNSRecordType = "AAAA"
	DNSRecordTypeCname DNSRecordType = "CNAME"
	DNSRecordTypeTxt   DNSRecordType = "TXT"
)

var AllDNSRecordType = []DNSRecordType{
	DNSRecordTypeA,
	DNSRecordTypeAaaa,
	DNSRecordTypeCname,
	DNSRecordTypeTxt,
}

func (e DNSRecordType) IsValid() bool {
	switch e {
	case DNSRecordTypeA, DNSRecordTypeAaaa, DNSRecordTypeCname, DNSRecordTypeTxt:
		return true
	}
	return false
}

func (e DNSRecordType) String() string {
	return string(e)
}

func (e *DNSRecordType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DNSRecordType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DnsRecordType", str)
	}
	return nil
}

func (e DNSRecordType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ImageGrade string

const (
	ImageGradeA ImageGrade = "A"
	ImageGradeB ImageGrade = "B"
	ImageGradeC ImageGrade = "C"
	ImageGradeD ImageGrade = "D"
	ImageGradeF ImageGrade = "F"
)

var AllImageGrade = []ImageGrade{
	ImageGradeA,
	ImageGradeB,
	ImageGradeC,
	ImageGradeD,
	ImageGradeF,
}

func (e ImageGrade) IsValid() bool {
	switch e {
	case ImageGradeA, ImageGradeB, ImageGradeC, ImageGradeD, ImageGradeF:
		return true
	}
	return false
}

func (e ImageGrade) String() string {
	return string(e)
}

func (e *ImageGrade) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ImageGrade(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ImageGrade", str)
	}
	return nil
}

func (e ImageGrade) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type IncidentAction string

const (
	IncidentActionAccept   IncidentAction = "ACCEPT"
	IncidentActionComplete IncidentAction = "COMPLETE"
	IncidentActionCreate   IncidentAction = "CREATE"
	IncidentActionEdit     IncidentAction = "EDIT"
	IncidentActionSeverity IncidentAction = "SEVERITY"
	IncidentActionStatus   IncidentAction = "STATUS"
)

var AllIncidentAction = []IncidentAction{
	IncidentActionAccept,
	IncidentActionComplete,
	IncidentActionCreate,
	IncidentActionEdit,
	IncidentActionSeverity,
	IncidentActionStatus,
}

func (e IncidentAction) IsValid() bool {
	switch e {
	case IncidentActionAccept, IncidentActionComplete, IncidentActionCreate, IncidentActionEdit, IncidentActionSeverity, IncidentActionStatus:
		return true
	}
	return false
}

func (e IncidentAction) String() string {
	return string(e)
}

func (e *IncidentAction) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IncidentAction(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IncidentAction", str)
	}
	return nil
}

func (e IncidentAction) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type IncidentFilterType string

const (
	IncidentFilterTypeFollowing     IncidentFilterType = "FOLLOWING"
	IncidentFilterTypeNotifications IncidentFilterType = "NOTIFICATIONS"
	IncidentFilterTypeStatus        IncidentFilterType = "STATUS"
	IncidentFilterTypeTag           IncidentFilterType = "TAG"
)

var AllIncidentFilterType = []IncidentFilterType{
	IncidentFilterTypeFollowing,
	IncidentFilterTypeNotifications,
	IncidentFilterTypeStatus,
	IncidentFilterTypeTag,
}

func (e IncidentFilterType) IsValid() bool {
	switch e {
	case IncidentFilterTypeFollowing, IncidentFilterTypeNotifications, IncidentFilterTypeStatus, IncidentFilterTypeTag:
		return true
	}
	return false
}

func (e IncidentFilterType) String() string {
	return string(e)
}

func (e *IncidentFilterType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IncidentFilterType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IncidentFilterType", str)
	}
	return nil
}

func (e IncidentFilterType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type IncidentSort string

const (
	IncidentSortInsertedAt IncidentSort = "INSERTED_AT"
	IncidentSortSeverity   IncidentSort = "SEVERITY"
	IncidentSortStatus     IncidentSort = "STATUS"
	IncidentSortTitle      IncidentSort = "TITLE"
)

var AllIncidentSort = []IncidentSort{
	IncidentSortInsertedAt,
	IncidentSortSeverity,
	IncidentSortStatus,
	IncidentSortTitle,
}

func (e IncidentSort) IsValid() bool {
	switch e {
	case IncidentSortInsertedAt, IncidentSortSeverity, IncidentSortStatus, IncidentSortTitle:
		return true
	}
	return false
}

func (e IncidentSort) String() string {
	return string(e)
}

func (e *IncidentSort) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IncidentSort(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IncidentSort", str)
	}
	return nil
}

func (e IncidentSort) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type IncidentStatus string

const (
	IncidentStatusComplete   IncidentStatus = "COMPLETE"
	IncidentStatusInProgress IncidentStatus = "IN_PROGRESS"
	IncidentStatusOpen       IncidentStatus = "OPEN"
	IncidentStatusResolved   IncidentStatus = "RESOLVED"
)

var AllIncidentStatus = []IncidentStatus{
	IncidentStatusComplete,
	IncidentStatusInProgress,
	IncidentStatusOpen,
	IncidentStatusResolved,
}

func (e IncidentStatus) IsValid() bool {
	switch e {
	case IncidentStatusComplete, IncidentStatusInProgress, IncidentStatusOpen, IncidentStatusResolved:
		return true
	}
	return false
}

func (e IncidentStatus) String() string {
	return string(e)
}

func (e *IncidentStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IncidentStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IncidentStatus", str)
	}
	return nil
}

func (e IncidentStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type LoginMethod string

const (
	LoginMethodGithub       LoginMethod = "GITHUB"
	LoginMethodGoogle       LoginMethod = "GOOGLE"
	LoginMethodPassword     LoginMethod = "PASSWORD"
	LoginMethodPasswordless LoginMethod = "PASSWORDLESS"
	LoginMethodSso          LoginMethod = "SSO"
)

var AllLoginMethod = []LoginMethod{
	LoginMethodGithub,
	LoginMethodGoogle,
	LoginMethodPassword,
	LoginMethodPasswordless,
	LoginMethodSso,
}

func (e LoginMethod) IsValid() bool {
	switch e {
	case LoginMethodGithub, LoginMethodGoogle, LoginMethodPassword, LoginMethodPasswordless, LoginMethodSso:
		return true
	}
	return false
}

func (e LoginMethod) String() string {
	return string(e)
}

func (e *LoginMethod) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LoginMethod(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LoginMethod", str)
	}
	return nil
}

func (e LoginMethod) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type MediaType string

const (
	MediaTypeAudio MediaType = "AUDIO"
	MediaTypeImage MediaType = "IMAGE"
	MediaTypeOther MediaType = "OTHER"
	MediaTypePDF   MediaType = "PDF"
	MediaTypeVideo MediaType = "VIDEO"
)

var AllMediaType = []MediaType{
	MediaTypeAudio,
	MediaTypeImage,
	MediaTypeOther,
	MediaTypePDF,
	MediaTypeVideo,
}

func (e MediaType) IsValid() bool {
	switch e {
	case MediaTypeAudio, MediaTypeImage, MediaTypeOther, MediaTypePDF, MediaTypeVideo:
		return true
	}
	return false
}

func (e MediaType) String() string {
	return string(e)
}

func (e *MediaType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MediaType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MediaType", str)
	}
	return nil
}

func (e MediaType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type MessageEntityType string

const (
	MessageEntityTypeEmoji   MessageEntityType = "EMOJI"
	MessageEntityTypeMention MessageEntityType = "MENTION"
)

var AllMessageEntityType = []MessageEntityType{
	MessageEntityTypeEmoji,
	MessageEntityTypeMention,
}

func (e MessageEntityType) IsValid() bool {
	switch e {
	case MessageEntityTypeEmoji, MessageEntityTypeMention:
		return true
	}
	return false
}

func (e MessageEntityType) String() string {
	return string(e)
}

func (e *MessageEntityType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MessageEntityType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MessageEntityType", str)
	}
	return nil
}

func (e MessageEntityType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type NotificationType string

const (
	NotificationTypeIncidentUpdate NotificationType = "INCIDENT_UPDATE"
	NotificationTypeLocked         NotificationType = "LOCKED"
	NotificationTypeMention        NotificationType = "MENTION"
	NotificationTypeMessage        NotificationType = "MESSAGE"
)

var AllNotificationType = []NotificationType{
	NotificationTypeIncidentUpdate,
	NotificationTypeLocked,
	NotificationTypeMention,
	NotificationTypeMessage,
}

func (e NotificationType) IsValid() bool {
	switch e {
	case NotificationTypeIncidentUpdate, NotificationTypeLocked, NotificationTypeMention, NotificationTypeMessage:
		return true
	}
	return false
}

func (e NotificationType) String() string {
	return string(e)
}

func (e *NotificationType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NotificationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NotificationType", str)
	}
	return nil
}

func (e NotificationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type OauthProvider string

const (
	OauthProviderGithub OauthProvider = "GITHUB"
	OauthProviderGitlab OauthProvider = "GITLAB"
	OauthProviderGoogle OauthProvider = "GOOGLE"
)

var AllOauthProvider = []OauthProvider{
	OauthProviderGithub,
	OauthProviderGitlab,
	OauthProviderGoogle,
}

func (e OauthProvider) IsValid() bool {
	switch e {
	case OauthProviderGithub, OauthProviderGitlab, OauthProviderGoogle:
		return true
	}
	return false
}

func (e OauthProvider) String() string {
	return string(e)
}

func (e *OauthProvider) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OauthProvider(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OauthProvider", str)
	}
	return nil
}

func (e OauthProvider) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type OauthService string

const (
	OauthServiceZoom OauthService = "ZOOM"
)

var AllOauthService = []OauthService{
	OauthServiceZoom,
}

func (e OauthService) IsValid() bool {
	switch e {
	case OauthServiceZoom:
		return true
	}
	return false
}

func (e OauthService) String() string {
	return string(e)
}

func (e *OauthService) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OauthService(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OauthService", str)
	}
	return nil
}

func (e OauthService) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type OidcAuthMethod string

const (
	OidcAuthMethodBasic OidcAuthMethod = "BASIC"
	OidcAuthMethodPost  OidcAuthMethod = "POST"
)

var AllOidcAuthMethod = []OidcAuthMethod{
	OidcAuthMethodBasic,
	OidcAuthMethodPost,
}

func (e OidcAuthMethod) IsValid() bool {
	switch e {
	case OidcAuthMethodBasic, OidcAuthMethodPost:
		return true
	}
	return false
}

func (e OidcAuthMethod) String() string {
	return string(e)
}

func (e *OidcAuthMethod) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OidcAuthMethod(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OidcAuthMethod", str)
	}
	return nil
}

func (e OidcAuthMethod) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type OnboardingChecklistState string

const (
	OnboardingChecklistStateConfigured       OnboardingChecklistState = "CONFIGURED"
	OnboardingChecklistStateConsoleInstalled OnboardingChecklistState = "CONSOLE_INSTALLED"
	OnboardingChecklistStateFinished         OnboardingChecklistState = "FINISHED"
	OnboardingChecklistStateNew              OnboardingChecklistState = "NEW"
)

var AllOnboardingChecklistState = []OnboardingChecklistState{
	OnboardingChecklistStateConfigured,
	OnboardingChecklistStateConsoleInstalled,
	OnboardingChecklistStateFinished,
	OnboardingChecklistStateNew,
}

func (e OnboardingChecklistState) IsValid() bool {
	switch e {
	case OnboardingChecklistStateConfigured, OnboardingChecklistStateConsoleInstalled, OnboardingChecklistStateFinished, OnboardingChecklistStateNew:
		return true
	}
	return false
}

func (e OnboardingChecklistState) String() string {
	return string(e)
}

func (e *OnboardingChecklistState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OnboardingChecklistState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OnboardingChecklistState", str)
	}
	return nil
}

func (e OnboardingChecklistState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type OnboardingState string

const (
	OnboardingStateActive    OnboardingState = "ACTIVE"
	OnboardingStateInstalled OnboardingState = "INSTALLED"
	OnboardingStateNew       OnboardingState = "NEW"
	OnboardingStateOnboarded OnboardingState = "ONBOARDED"
)

var AllOnboardingState = []OnboardingState{
	OnboardingStateActive,
	OnboardingStateInstalled,
	OnboardingStateNew,
	OnboardingStateOnboarded,
}

func (e OnboardingState) IsValid() bool {
	switch e {
	case OnboardingStateActive, OnboardingStateInstalled, OnboardingStateNew, OnboardingStateOnboarded:
		return true
	}
	return false
}

func (e OnboardingState) String() string {
	return string(e)
}

func (e *OnboardingState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OnboardingState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OnboardingState", str)
	}
	return nil
}

func (e OnboardingState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Operation string

const (
	OperationEq     Operation = "EQ"
	OperationGt     Operation = "GT"
	OperationGte    Operation = "GTE"
	OperationLt     Operation = "LT"
	OperationLte    Operation = "LTE"
	OperationNot    Operation = "NOT"
	OperationPrefix Operation = "PREFIX"
	OperationSuffix Operation = "SUFFIX"
)

var AllOperation = []Operation{
	OperationEq,
	OperationGt,
	OperationGte,
	OperationLt,
	OperationLte,
	OperationNot,
	OperationPrefix,
	OperationSuffix,
}

func (e Operation) IsValid() bool {
	switch e {
	case OperationEq, OperationGt, OperationGte, OperationLt, OperationLte, OperationNot, OperationPrefix, OperationSuffix:
		return true
	}
	return false
}

func (e Operation) String() string {
	return string(e)
}

func (e *Operation) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Operation(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Operation", str)
	}
	return nil
}

func (e Operation) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Order string

const (
	OrderAsc  Order = "ASC"
	OrderDesc Order = "DESC"
)

var AllOrder = []Order{
	OrderAsc,
	OrderDesc,
}

func (e Order) IsValid() bool {
	switch e {
	case OrderAsc, OrderDesc:
		return true
	}
	return false
}

func (e Order) String() string {
	return string(e)
}

func (e *Order) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Order(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Order", str)
	}
	return nil
}

func (e Order) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Permission string

const (
	PermissionBilling      Permission = "BILLING"
	PermissionInstall      Permission = "INSTALL"
	PermissionIntegrations Permission = "INTEGRATIONS"
	PermissionPublish      Permission = "PUBLISH"
	PermissionSupport      Permission = "SUPPORT"
	PermissionUsers        Permission = "USERS"
)

var AllPermission = []Permission{
	PermissionBilling,
	PermissionInstall,
	PermissionIntegrations,
	PermissionPublish,
	PermissionSupport,
	PermissionUsers,
}

func (e Permission) IsValid() bool {
	switch e {
	case PermissionBilling, PermissionInstall, PermissionIntegrations, PermissionPublish, PermissionSupport, PermissionUsers:
		return true
	}
	return false
}

func (e Permission) String() string {
	return string(e)
}

func (e *Permission) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Permission(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Permission", str)
	}
	return nil
}

func (e Permission) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PlanType string

const (
	PlanTypeLicensed PlanType = "LICENSED"
	PlanTypeMetered  PlanType = "METERED"
)

var AllPlanType = []PlanType{
	PlanTypeLicensed,
	PlanTypeMetered,
}

func (e PlanType) IsValid() bool {
	switch e {
	case PlanTypeLicensed, PlanTypeMetered:
		return true
	}
	return false
}

func (e PlanType) String() string {
	return string(e)
}

func (e *PlanType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PlanType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PlanType", str)
	}
	return nil
}

func (e PlanType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Provider string

const (
	ProviderAws        Provider = "AWS"
	ProviderAzure      Provider = "AZURE"
	ProviderCustom     Provider = "CUSTOM"
	ProviderEquinix    Provider = "EQUINIX"
	ProviderGcp        Provider = "GCP"
	ProviderKind       Provider = "KIND"
	ProviderKubernetes Provider = "KUBERNETES"
)

var AllProvider = []Provider{
	ProviderAws,
	ProviderAzure,
	ProviderCustom,
	ProviderEquinix,
	ProviderGcp,
	ProviderKind,
	ProviderKubernetes,
}

func (e Provider) IsValid() bool {
	switch e {
	case ProviderAws, ProviderAzure, ProviderCustom, ProviderEquinix, ProviderGcp, ProviderKind, ProviderKubernetes:
		return true
	}
	return false
}

func (e Provider) String() string {
	return string(e)
}

func (e *Provider) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Provider(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Provider", str)
	}
	return nil
}

func (e Provider) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type RecipeItemType string

const (
	RecipeItemTypeHelm      RecipeItemType = "HELM"
	RecipeItemTypeTerraform RecipeItemType = "TERRAFORM"
)

var AllRecipeItemType = []RecipeItemType{
	RecipeItemTypeHelm,
	RecipeItemTypeTerraform,
}

func (e RecipeItemType) IsValid() bool {
	switch e {
	case RecipeItemTypeHelm, RecipeItemTypeTerraform:
		return true
	}
	return false
}

func (e RecipeItemType) String() string {
	return string(e)
}

func (e *RecipeItemType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RecipeItemType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RecipeItemType", str)
	}
	return nil
}

func (e RecipeItemType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ResetTokenType string

const (
	ResetTokenTypeEmail    ResetTokenType = "EMAIL"
	ResetTokenTypePassword ResetTokenType = "PASSWORD"
)

var AllResetTokenType = []ResetTokenType{
	ResetTokenTypeEmail,
	ResetTokenTypePassword,
}

func (e ResetTokenType) IsValid() bool {
	switch e {
	case ResetTokenTypeEmail, ResetTokenTypePassword:
		return true
	}
	return false
}

func (e ResetTokenType) String() string {
	return string(e)
}

func (e *ResetTokenType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ResetTokenType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ResetTokenType", str)
	}
	return nil
}

func (e ResetTokenType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type RolloutStatus string

const (
	RolloutStatusFinished RolloutStatus = "FINISHED"
	RolloutStatusQueued   RolloutStatus = "QUEUED"
	RolloutStatusRunning  RolloutStatus = "RUNNING"
)

var AllRolloutStatus = []RolloutStatus{
	RolloutStatusFinished,
	RolloutStatusQueued,
	RolloutStatusRunning,
}

func (e RolloutStatus) IsValid() bool {
	switch e {
	case RolloutStatusFinished, RolloutStatusQueued, RolloutStatusRunning:
		return true
	}
	return false
}

func (e RolloutStatus) String() string {
	return string(e)
}

func (e *RolloutStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RolloutStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RolloutStatus", str)
	}
	return nil
}

func (e RolloutStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ScmProvider string

const (
	ScmProviderGithub ScmProvider = "GITHUB"
	ScmProviderGitlab ScmProvider = "GITLAB"
)

var AllScmProvider = []ScmProvider{
	ScmProviderGithub,
	ScmProviderGitlab,
}

func (e ScmProvider) IsValid() bool {
	switch e {
	case ScmProviderGithub, ScmProviderGitlab:
		return true
	}
	return false
}

func (e ScmProvider) String() string {
	return string(e)
}

func (e *ScmProvider) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ScmProvider(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ScmProvider", str)
	}
	return nil
}

func (e ScmProvider) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SpecDatatype string

const (
	SpecDatatypeBool   SpecDatatype = "BOOL"
	SpecDatatypeFloat  SpecDatatype = "FLOAT"
	SpecDatatypeInt    SpecDatatype = "INT"
	SpecDatatypeList   SpecDatatype = "LIST"
	SpecDatatypeObject SpecDatatype = "OBJECT"
	SpecDatatypeString SpecDatatype = "STRING"
)

var AllSpecDatatype = []SpecDatatype{
	SpecDatatypeBool,
	SpecDatatypeFloat,
	SpecDatatypeInt,
	SpecDatatypeList,
	SpecDatatypeObject,
	SpecDatatypeString,
}

func (e SpecDatatype) IsValid() bool {
	switch e {
	case SpecDatatypeBool, SpecDatatypeFloat, SpecDatatypeInt, SpecDatatypeList, SpecDatatypeObject, SpecDatatypeString:
		return true
	}
	return false
}

func (e SpecDatatype) String() string {
	return string(e)
}

func (e *SpecDatatype) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SpecDatatype(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SpecDatatype", str)
	}
	return nil
}

func (e SpecDatatype) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TagGroup string

const (
	TagGroupIntegrations TagGroup = "INTEGRATIONS"
	TagGroupRepositories TagGroup = "REPOSITORIES"
)

var AllTagGroup = []TagGroup{
	TagGroupIntegrations,
	TagGroupRepositories,
}

func (e TagGroup) IsValid() bool {
	switch e {
	case TagGroupIntegrations, TagGroupRepositories:
		return true
	}
	return false
}

func (e TagGroup) String() string {
	return string(e)
}

func (e *TagGroup) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TagGroup(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TagGroup", str)
	}
	return nil
}

func (e TagGroup) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TestStatus string

const (
	TestStatusFailed    TestStatus = "FAILED"
	TestStatusQueued    TestStatus = "QUEUED"
	TestStatusRunning   TestStatus = "RUNNING"
	TestStatusSucceeded TestStatus = "SUCCEEDED"
)

var AllTestStatus = []TestStatus{
	TestStatusFailed,
	TestStatusQueued,
	TestStatusRunning,
	TestStatusSucceeded,
}

func (e TestStatus) IsValid() bool {
	switch e {
	case TestStatusFailed, TestStatusQueued, TestStatusRunning, TestStatusSucceeded:
		return true
	}
	return false
}

func (e TestStatus) String() string {
	return string(e)
}

func (e *TestStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TestStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TestStatus", str)
	}
	return nil
}

func (e TestStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TestType string

const (
	TestTypeGit TestType = "GIT"
)

var AllTestType = []TestType{
	TestTypeGit,
}

func (e TestType) IsValid() bool {
	switch e {
	case TestTypeGit:
		return true
	}
	return false
}

func (e TestType) String() string {
	return string(e)
}

func (e *TestType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TestType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TestType", str)
	}
	return nil
}

func (e TestType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UpgradeType string

const (
	UpgradeTypeApproval UpgradeType = "APPROVAL"
	UpgradeTypeBounce   UpgradeType = "BOUNCE"
	UpgradeTypeDeploy   UpgradeType = "DEPLOY"
)

var AllUpgradeType = []UpgradeType{
	UpgradeTypeApproval,
	UpgradeTypeBounce,
	UpgradeTypeDeploy,
}

func (e UpgradeType) IsValid() bool {
	switch e {
	case UpgradeTypeApproval, UpgradeTypeBounce, UpgradeTypeDeploy:
		return true
	}
	return false
}

func (e UpgradeType) String() string {
	return string(e)
}

func (e *UpgradeType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UpgradeType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UpgradeType", str)
	}
	return nil
}

func (e UpgradeType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UserEventStatus string

const (
	UserEventStatusError UserEventStatus = "ERROR"
	UserEventStatusOk    UserEventStatus = "OK"
)

var AllUserEventStatus = []UserEventStatus{
	UserEventStatusError,
	UserEventStatusOk,
}

func (e UserEventStatus) IsValid() bool {
	switch e {
	case UserEventStatusError, UserEventStatusOk:
		return true
	}
	return false
}

func (e UserEventStatus) String() string {
	return string(e)
}

func (e *UserEventStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserEventStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserEventStatus", str)
	}
	return nil
}

func (e UserEventStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ValidationType string

const (
	ValidationTypeRegex ValidationType = "REGEX"
)

var AllValidationType = []ValidationType{
	ValidationTypeRegex,
}

func (e ValidationType) IsValid() bool {
	switch e {
	case ValidationTypeRegex:
		return true
	}
	return false
}

func (e ValidationType) String() string {
	return string(e)
}

func (e *ValidationType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ValidationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ValidationType", str)
	}
	return nil
}

func (e ValidationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type VulnGrade string

const (
	VulnGradeCritical VulnGrade = "CRITICAL"
	VulnGradeHigh     VulnGrade = "HIGH"
	VulnGradeLow      VulnGrade = "LOW"
	VulnGradeMedium   VulnGrade = "MEDIUM"
	VulnGradeNone     VulnGrade = "NONE"
)

var AllVulnGrade = []VulnGrade{
	VulnGradeCritical,
	VulnGradeHigh,
	VulnGradeLow,
	VulnGradeMedium,
	VulnGradeNone,
}

func (e VulnGrade) IsValid() bool {
	switch e {
	case VulnGradeCritical, VulnGradeHigh, VulnGradeLow, VulnGradeMedium, VulnGradeNone:
		return true
	}
	return false
}

func (e VulnGrade) String() string {
	return string(e)
}

func (e *VulnGrade) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VulnGrade(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VulnGrade", str)
	}
	return nil
}

func (e VulnGrade) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type VulnRequirement string

const (
	VulnRequirementNone     VulnRequirement = "NONE"
	VulnRequirementRequired VulnRequirement = "REQUIRED"
)

var AllVulnRequirement = []VulnRequirement{
	VulnRequirementNone,
	VulnRequirementRequired,
}

func (e VulnRequirement) IsValid() bool {
	switch e {
	case VulnRequirementNone, VulnRequirementRequired:
		return true
	}
	return false
}

func (e VulnRequirement) String() string {
	return string(e)
}

func (e *VulnRequirement) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VulnRequirement(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VulnRequirement", str)
	}
	return nil
}

func (e VulnRequirement) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type VulnVector string

const (
	VulnVectorAdjacent VulnVector = "ADJACENT"
	VulnVectorLocal    VulnVector = "LOCAL"
	VulnVectorNetwork  VulnVector = "NETWORK"
	VulnVectorPhysical VulnVector = "PHYSICAL"
)

var AllVulnVector = []VulnVector{
	VulnVectorAdjacent,
	VulnVectorLocal,
	VulnVectorNetwork,
	VulnVectorPhysical,
}

func (e VulnVector) IsValid() bool {
	switch e {
	case VulnVectorAdjacent, VulnVectorLocal, VulnVectorNetwork, VulnVectorPhysical:
		return true
	}
	return false
}

func (e VulnVector) String() string {
	return string(e)
}

func (e *VulnVector) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VulnVector(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VulnVector", str)
	}
	return nil
}

func (e VulnVector) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type WebhookLogState string

const (
	WebhookLogStateDelivered WebhookLogState = "DELIVERED"
	WebhookLogStateFailed    WebhookLogState = "FAILED"
	WebhookLogStateSending   WebhookLogState = "SENDING"
)

var AllWebhookLogState = []WebhookLogState{
	WebhookLogStateDelivered,
	WebhookLogStateFailed,
	WebhookLogStateSending,
}

func (e WebhookLogState) IsValid() bool {
	switch e {
	case WebhookLogStateDelivered, WebhookLogStateFailed, WebhookLogStateSending:
		return true
	}
	return false
}

func (e WebhookLogState) String() string {
	return string(e)
}

func (e *WebhookLogState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WebhookLogState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WebhookLogState", str)
	}
	return nil
}

func (e WebhookLogState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
